<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CatLib</name>
    </assembly>
    <members>
        <member name="T:SharpCompress.Compressors.CompressionMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.CompressionMode.Compress">
            <summary>
            
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.CompressionMode.Decompress">
            <summary>
            
            </summary>
        </member>
        <member name="T:SharpCompress.Compressors.LZMA.DataErrorException">
            <summary>
            The exception that is thrown when an error in input stream occurs during decoding.
            </summary>
        </member>
        <member name="T:SharpCompress.Compressors.LZMA.InvalidParamException">
            <summary>
            The exception that is thrown when the value of an argument is outside the allowable range.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.ICodeProgress.SetProgress(System.Int64,System.Int64)">
            <summary>
            Callback progress.
            </summary>
            <param name="inSize">
            input size. -1 if unknown.
            </param>
            <param name="outSize">
            output size. -1 if unknown.
            </param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.ICoder.Code(System.IO.Stream,System.IO.Stream,System.Int64,System.Int64,SharpCompress.Compressors.LZMA.ICodeProgress)">
            <summary>
            Codes streams.
            </summary>
            <param name="inStream">
            input Stream.
            </param>
            <param name="outStream">
            output Stream.
            </param>
            <param name="inSize">
            input Size. -1 if unknown.
            </param>
            <param name="outSize">
            output Size. -1 if unknown.
            </param>
            <param name="progress">
            callback progress reference.
            </param>
        </member>
        <member name="T:SharpCompress.Compressors.LZMA.CoderPropID">
            <summary>
            Provides the fields that represent properties idenitifiers for compressing.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.DefaultProp">
            <summary>
            Specifies default property.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.DictionarySize">
            <summary>
            Specifies size of dictionary.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.UsedMemorySize">
            <summary>
            Specifies size of memory for PPM*.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.Order">
            <summary>
            Specifies order for PPM methods.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.BlockSize">
            <summary>
            Specifies Block Size.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.PosStateBits">
            <summary>
            Specifies number of postion state bits for LZMA (0 - x - 4).
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.LitContextBits">
            <summary>
            Specifies number of literal context bits for LZMA (0 - x - 8).
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.LitPosBits">
            <summary>
            Specifies number of literal position bits for LZMA (0 - x - 4).
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.NumFastBytes">
            <summary>
            Specifies number of fast bytes for LZ*.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.MatchFinder">
            <summary>
            Specifies match finder. LZMA: "BT2", "BT4" or "BT4B".
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.MatchFinderCycles">
            <summary>
            Specifies the number of match finder cyckes.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.NumPasses">
            <summary>
            Specifies number of passes.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.Algorithm">
            <summary>
            Specifies number of algorithm.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.NumThreads">
            <summary>
            Specifies the number of threads.
            </summary>
        </member>
        <member name="F:SharpCompress.Compressors.LZMA.CoderPropID.EndMarker">
            <summary>
            Specifies mode with end marker.
            </summary>
        </member>
        <member name="T:SharpCompress.Compressors.LZMA.LZipStream">
            <summary>
            Stream supporting the LZIP format, as documented at http://www.nongnu.org/lzip/manual/lzip_manual.html
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.#ctor(System.IO.Stream,SharpCompress.Compressors.CompressionMode,System.Boolean)">
            <summary>
            
            </summary>
            <param name="stream"></param>
            <param name="mode"></param>
            <param name="leaveOpen"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.Finish">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LZipStream.Mode">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LZipStream.CanRead">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LZipStream.CanSeek">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LZipStream.CanWrite">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.Flush">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LZipStream.Length">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LZipStream.Position">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.SetLength(System.Int64)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.IsLZipFile(System.IO.Stream)">
            <summary>
            Determines if the given stream is positioned at the start of a v1 LZip
            file, as indicated by the ASCII characters "LZIP" and a version byte
            of 1, followed by at least one byte.
            </summary>
            <param name="stream">The stream to read from. Must not be null.</param>
            <returns><c>true</c> if the given stream is an LZip file, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.ValidateAndReadSize(System.IO.Stream)">
            <summary>
            Reads the 6-byte header of the stream, and returns 0 if either the header
            couldn't be read or it isn't a validate LZIP header, or the dictionary
            size if it *is* a valid LZIP file.
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.WriteHeaderSize(System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LZipStream.GetProperties(System.Int32)">
            <summary>
            Creates a byte array to communicate the parameters and dictionary size to LzmaStream.
            </summary>
        </member>
        <member name="T:SharpCompress.Compressors.LZMA.LzmaEncoderProperties">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaEncoderProperties.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaEncoderProperties.#ctor(System.Boolean)">
            <summary>
            
            </summary>
            <param name="eos"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaEncoderProperties.#ctor(System.Boolean,System.Int32)">
            <summary>
            
            </summary>
            <param name="eos"></param>
            <param name="dictionary"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaEncoderProperties.#ctor(System.Boolean,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="eos"></param>
            <param name="dictionary"></param>
            <param name="numFastBytes"></param>
        </member>
        <member name="T:SharpCompress.Compressors.LZMA.LzmaStream">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.#ctor(System.Byte[],System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="properties"></param>
            <param name="inputStream"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.#ctor(System.Byte[],System.IO.Stream,System.Int64)">
            <summary>
            
            </summary>
            <param name="properties"></param>
            <param name="inputStream"></param>
            <param name="inputSize"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.#ctor(System.Byte[],System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            
            </summary>
            <param name="properties"></param>
            <param name="inputStream"></param>
            <param name="inputSize"></param>
            <param name="outputSize"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.#ctor(System.Byte[],System.IO.Stream,System.Int64,System.Int64,System.IO.Stream,System.Boolean)">
            <summary>
            
            </summary>
            <param name="properties"></param>
            <param name="inputStream"></param>
            <param name="inputSize"></param>
            <param name="outputSize"></param>
            <param name="presetDictionary"></param>
            <param name="isLZMA2"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.#ctor(SharpCompress.Compressors.LZMA.LzmaEncoderProperties,System.Boolean,System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="properties"></param>
            <param name="isLZMA2"></param>
            <param name="outputStream"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.#ctor(SharpCompress.Compressors.LZMA.LzmaEncoderProperties,System.Boolean,System.IO.Stream,System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="properties"></param>
            <param name="isLZMA2"></param>
            <param name="presetDictionary"></param>
            <param name="outputStream"></param>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LzmaStream.CanRead">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LzmaStream.CanSeek">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LzmaStream.CanWrite">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.Flush">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LzmaStream.Length">
            <summary>
            
            </summary>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LzmaStream.Position">
            <summary>
            
            </summary>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.SetLength(System.Int64)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:SharpCompress.Compressors.LZMA.LzmaStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="P:SharpCompress.Compressors.LZMA.LzmaStream.Properties">
            <summary>
            
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Checksum.Adler32">
            <summary>
            Computes Adler32 checksum for a stream of data. An Adler32
            checksum is not as reliable as a CRC32 checksum, but a lot faster to
            compute.
            
            The specification for Adler32 may be found in RFC 1950.
            ZLIB Compressed Data Format Specification version 3.3)
            
            
            From that document:
            
                 "ADLER32 (Adler-32 checksum)
                  This contains a checksum value of the uncompressed data
                  (excluding any dictionary data) computed according to Adler-32
                  algorithm. This algorithm is a 32-bit extension and improvement
                  of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                  standard.
            
                  Adler-32 is composed of two sums accumulated per byte: s1 is
                  the sum of all bytes, s2 is the sum of all s1 values. Both sums
                  are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                  Adler-32 checksum is stored as s2*65536 + s1 in most-
                  significant-byte first (network) order."
            
             "8.2. The Adler-32 algorithm
            
               The Adler-32 algorithm is much faster than the CRC32 algorithm yet
               still provides an extremely low probability of undetected errors.
            
               The modulo on unsigned long accumulators can be delayed for 5552
               bytes, so the modulo operation time is negligible.  If the bytes
               are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
               and order sensitive, unlike the first sum, which is just a
               checksum.  That 65521 is prime is important to avoid a possible
               large class of two-byte errors that leave the check unchanged.
               (The Fletcher checksum uses 255, which is not prime and which also
               makes the Fletcher check insensitive to single byte changes 0 -
               255.)
            
               The sum s1 is initialized to 1 instead of zero to make the length
               of the sequence part of s2, so that the length does not have to be
               checked separately. (Any sequence of zeroes has a Fletcher
               checksum of zero.)"
            </summary>
            <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream"/>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Checksum.Adler32.BASE">
            <summary>
            largest prime smaller than 65536
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Checksum.Adler32.checkValue">
            <summary>
            The CRC data checksum so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Adler32.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:ICSharpCode.SharpZipLib.Checksum.Adler32"></see>
            </summary>	
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Adler32.Reset">
            <summary>
            Resets the Adler32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Checksum.Adler32.Value">
            <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Adler32.Update(System.Int32)">
            <summary>
            Updates the checksum with the byte b.
            </summary>
            <param name="bval">
            The data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Adler32.Update(System.Byte[])">
            <summary>
            Updates the Adler32 data checksum with the bytes taken from 
            a block of data.
            </summary>
            <param name="buffer">Contains the data to update the checksum with.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update Adler32 data checksum based on a portion of a block of data
            </summary>
            <param name = "buffer">Contains the data to update the CRC with.</param>
            <param name = "offset">The offset into the buffer where the data starts</param>
            <param name = "count">The number of data bytes to update the CRC with.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Checksum.Crc32">
             <summary>
             CRC-32 with reversed data and unreversed output
             </summary>
             <remarks>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Checksum.Crc32.checkValue">
            <summary>
            The CRC data checksum so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Crc32.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:ICSharpCode.SharpZipLib.Checksum.Crc32"></see>
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Crc32.Reset">
            <summary>
            Resets the CRC data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Checksum.Crc32.Value">
            <summary>
            Returns the CRC data checksum computed so far.
            </summary>
            <remarks>Reversed Out = false</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "bval">
            the byte is taken as the lower 8 bits of bval
            </param>
            <remarks>Reversed Data = true</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Crc32.Update(System.Byte[])">
            <summary>
            Updates the CRC data checksum with the bytes taken from 
            a block of data.
            </summary>
            <param name="buffer">Contains the data to update the CRC with.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update CRC data checksum based on a portion of a block of data
            </summary>
            <param name = "buffer">Contains the data to update the CRC with.</param>
            <param name = "offset">The offset into the buffer where the data starts</param>
            <param name = "count">The number of data bytes to update the CRC with.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Checksum.IChecksum">
            <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.IChecksum.Reset">
            <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Checksum.IChecksum.Value">
            <summary>
            Returns the data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.IChecksum.Update(System.Int32)">
            <summary>
            Adds one byte to the data checksum.
            </summary>
            <param name = "bval">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.IChecksum.Update(System.Byte[])">
            <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Checksum.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            the number of data bytes to add.
            </param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.ScanEventArgs">
            <summary>
            Event arguments for scanning.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.ScanEventArgs.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.ScanEventArgs"/>
            </summary>
            <param name="name">The file or directory name.</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ScanEventArgs.Name">
            <summary>
            The file or directory name for this event.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ScanEventArgs.ContinueRunning">
            <summary>
            Get set a value indicating if scanning should continue or not.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.ProgressEventArgs">
            <summary>
            Event arguments during processing of a single file or directory.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.ScanEventArgs"/>
            </summary>
            <param name="name">The file or directory name if known.</param>
            <param name="processed">The number of bytes processed so far</param>
            <param name="target">The total number of bytes to process, 0 if not known</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.Name">
            <summary>
            The name for this event if known.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.ContinueRunning">
            <summary>
            Get set a value indicating wether scanning should continue or not.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.PercentComplete">
            <summary>
            Get a percentage representing how much of the <see cref="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.Target"></see> has been processed
            </summary>
            <value>0.0 to 100.0 percent; 0 if target is not known.</value>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.Processed">
            <summary>
            The number of bytes processed so far
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ProgressEventArgs.Target">
            <summary>
            The number of bytes to process.
            </summary>
            <remarks>Target may be 0 or negative if the value isnt known.</remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs">
            <summary>
            Event arguments for directories.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs.#ctor(System.String,System.Boolean)">
            <summary>
            Initialize an instance of <see cref="T:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs"></see>.
            </summary>
            <param name="name">The name for this directory.</param>
            <param name="hasMatchingFiles">Flag value indicating if any matching files are contained in this directory.</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.DirectoryEventArgs.HasMatchingFiles">
            <summary>
            Get a value indicating if the directory contains any matching files or not.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs">
            <summary>
            Arguments passed when scan failures are detected.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs"></see>
            </summary>
            <param name="name">The name to apply.</param>
            <param name="e">The exception to use.</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.Name">
            <summary>
            The applicable name.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.Exception">
            <summary>
            The applicable exception.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ScanFailureEventArgs.ContinueRunning">
            <summary>
            Get / set a value indicating wether scanning should continue.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.ProcessFileHandler">
            <summary>
            Delegate invoked before starting to process a file.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.ProgressHandler">
            <summary>
            Delegate invoked during processing of a file or directory
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.CompletedFileHandler">
            <summary>
            Delegate invoked when a file has been completely processed.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.DirectoryFailureHandler">
            <summary>
            Delegate invoked when a directory failure is detected.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.FileFailureHandler">
            <summary>
            Delegate invoked when a file failure is detected.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner">
            <summary>
            FileSystemScanner provides facilities scanning of files and directories.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="filter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter">file filter</see> to apply when scanning.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(System.String,System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
            <param name="directoryFilter">The <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter"> directory filter</see> to apply.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(ICSharpCode.SharpZipLib.Core.IScanFilter)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The file <see cref="T:ICSharpCode.SharpZipLib.Core.IScanFilter">filter</see> to apply.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.#ctor(ICSharpCode.SharpZipLib.Core.IScanFilter,ICSharpCode.SharpZipLib.Core.IScanFilter)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The file <see cref="T:ICSharpCode.SharpZipLib.Core.IScanFilter">filter</see>  to apply.</param>
            <param name="directoryFilter">The directory <see cref="T:ICSharpCode.SharpZipLib.Core.IScanFilter">filter</see>  to apply.</param>
        </member>
        <member name="E:ICSharpCode.SharpZipLib.Core.FileSystemScanner.ProcessDirectory">
            <summary>
            Delegate to invoke when a directory is processed.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.ProcessFile">
            <summary>
            Delegate to invoke when a file is processed.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.CompletedFile">
            <summary>
            Delegate to invoke when processing for a file has finished.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.DirectoryFailure">
            <summary>
            Delegate to invoke when a directory failure is detected.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.FileFailure">
            <summary>
            Delegate to invoke when a file failure is detected.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnDirectoryFailure(System.String,System.Exception)">
            <summary>
            Raise the DirectoryFailure event.
            </summary>
            <param name="directory">The directory name.</param>
            <param name="e">The exception detected.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnFileFailure(System.String,System.Exception)">
            <summary>
            Raise the FileFailure event.
            </summary>
            <param name="file">The file name.</param>
            <param name="e">The exception detected.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnProcessFile(System.String)">
            <summary>
            Raise the ProcessFile event.
            </summary>
            <param name="file">The file name.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnCompleteFile(System.String)">
            <summary>
            Raise the complete file event
            </summary>
            <param name="file">The file name</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.OnProcessDirectory(System.String,System.Boolean)">
            <summary>
            Raise the ProcessDirectory event.
            </summary>
            <param name="directory">The directory name.</param>
            <param name="hasMatchingFiles">Flag indicating if the directory has matching files.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.FileSystemScanner.Scan(System.String,System.Boolean)">
            <summary>
            Scan a directory.
            </summary>
            <param name="directory">The base directory to scan.</param>
            <param name="recurse">True to recurse subdirectories, false to scan a single directory.</param>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.fileFilter_">
            <summary>
            The file filter currently in use.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.directoryFilter_">
            <summary>
            The directory filter currently in use.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Core.FileSystemScanner.alive_">
            <summary>
            Flag indicating if scanning should continue running.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.INameTransform">
            <summary>
            INameTransform defines how file system names are transformed for use with archives, or vice versa.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.INameTransform.TransformFile(System.String)">
            <summary>
            Given a file name determine the transformed value.
            </summary>
            <param name="name">The name to transform.</param>
            <returns>The transformed file name.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.INameTransform.TransformDirectory(System.String)">
            <summary>
            Given a directory name determine the transformed value.
            </summary>
            <param name="name">The name to transform.</param>
            <returns>The transformed directory name</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.IScanFilter">
            <summary>
            Scanning filters support filtering of names.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.IScanFilter.IsMatch(System.String)">
            <summary>
            Test a name to see if it 'matches' the filter.
            </summary>
            <param name="name">The name to test.</param>
            <returns>Returns true if the name matches the filter, false if it does not match.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.NameFilter">
            <summary>
            NameFilter is a string matching class which allows for both positive and negative
            matching.
            A filter is a sequence of independant <see cref="T:System.Text.RegularExpressions.Regex">regular expressions</see> separated by semi-colons ';'.
            To include a semi-colon it may be quoted as in \;. Each expression can be prefixed by a plus '+' sign or
            a minus '-' sign to denote the expression is intended to include or exclude names.
            If neither a plus or minus sign is found include is the default.
            A given name is tested for inclusion before checking exclusions.  Only names matching an include spec 
            and not matching an exclude spec are deemed to match the filter.
            An empty filter matches any name.
            </summary>
            <example>The following expression includes all name ending in '.dat' with the exception of 'dummy.dat'
            "+\.dat$;-^dummy\.dat$"
            </example>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.#ctor(System.String)">
            <summary>
            Construct an instance based on the filter expression passed
            </summary>
            <param name="filter">The filter expression.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsValidExpression(System.String)">
            <summary>
            Test a string to see if it is a valid regular expression.
            </summary>
            <param name="expression">The expression to test.</param>
            <returns>True if expression is a valid <see cref="T:System.Text.RegularExpressions.Regex"/> false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsValidFilterExpression(System.String)">
            <summary>
            Test an expression to see if it is valid as a filter.
            </summary>
            <param name="toTest">The filter expression to test.</param>
            <returns>True if the expression is valid, false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.SplitQuoted(System.String)">
            <summary>
            Split a string into its component pieces
            </summary>
            <param name="original">The original string</param>
            <returns>Returns an array of <see cref="T:System.String"/> values containing the individual filter elements.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.ToString">
            <summary>
            Convert this filter to its string equivalent.
            </summary>
            <returns>The string equivalent for this filter.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsIncluded(System.String)">
            <summary>
            Test a value to see if it is included by the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value is included, false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsExcluded(System.String)">
            <summary>
            Test a value to see if it is excluded by the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value is excluded, false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.IsMatch(System.String)">
            <summary>
            Test a value to see if it matches the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value matches, false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameFilter.Compile">
            <summary>
            Compile this filter.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.PathFilter">
            <summary>
            PathFilter filters directories and files using a form of <see cref="T:System.Text.RegularExpressions.Regex">regular expressions</see>
            by full path name.
            See <see cref="T:ICSharpCode.SharpZipLib.Core.NameFilter">NameFilter</see> for more detail on filtering.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.PathFilter.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Core.PathFilter"></see>.
            </summary>
            <param name="filter">The <see cref="T:ICSharpCode.SharpZipLib.Core.NameFilter">filter</see> expression to apply.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.PathFilter.IsMatch(System.String)">
            <summary>
            Test a name to see if it matches the filter.
            </summary>
            <param name="name">The name to test.</param>
            <returns>True if the name matches, false otherwise.</returns>
            <remarks><see cref="M:System.IO.Path.GetFullPath(System.String)"/> is used to get the full path before matching.</remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter">
            <summary>
            ExtendedPathFilter filters based on name, file size, and the last write time of the file.
            </summary>
            <remarks>Provides an example of how to customise filtering.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            Initialise a new instance of ExtendedPathFilter.
            </summary>
            <param name="filter">The filter to apply.</param>
            <param name="minSize">The minimum file size to include.</param>
            <param name="maxSize">The maximum file size to include.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.DateTime,System.DateTime)">
            <summary>
            Initialise a new instance of ExtendedPathFilter.
            </summary>
            <param name="filter">The filter to apply.</param>
            <param name="minDate">The minimum <see cref="T:System.DateTime"/> to include.</param>
            <param name="maxDate">The maximum <see cref="T:System.DateTime"/> to include.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.#ctor(System.String,System.Int64,System.Int64,System.DateTime,System.DateTime)">
            <summary>
            Initialise a new instance of ExtendedPathFilter.
            </summary>
            <param name="filter">The filter to apply.</param>
            <param name="minSize">The minimum file size to include.</param>
            <param name="maxSize">The maximum file size to include.</param>
            <param name="minDate">The minimum <see cref="T:System.DateTime"/> to include.</param>
            <param name="maxDate">The maximum <see cref="T:System.DateTime"/> to include.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.IsMatch(System.String)">
            <summary>
            Test a filename to see if it matches the filter.
            </summary>
            <param name="name">The filename to test.</param>
            <returns>True if the filter matches, false otherwise.</returns>
            <exception cref="T:System.IO.FileNotFoundException">The <see paramref="fileName"/> doesnt exist</exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MinSize">
            <summary>
            Get/set the minimum size/length for a file that will match this filter.
            </summary>
            <remarks>The default value is zero.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">value is less than zero; greater than <see cref="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MaxSize"/></exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MaxSize">
            <summary>
            Get/set the maximum size/length for a file that will match this filter.
            </summary>
            <remarks>The default value is <see cref="F:System.Int64.MaxValue"/></remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">value is less than zero or less than <see cref="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MinSize"/></exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MinDate">
            <summary>
            Get/set the minimum <see cref="T:System.DateTime"/> value that will match for this filter.
            </summary>
            <remarks>Files with a LastWrite time less than this value are excluded by the filter.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.ExtendedPathFilter.MaxDate">
            <summary>
            Get/set the maximum <see cref="T:System.DateTime"/> value that will match for this filter.
            </summary>
            <remarks>Files with a LastWrite time greater than this value are excluded by the filter.</remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter">
            <summary>
            NameAndSizeFilter filters based on name and file size.
            </summary>
            <remarks>A sample showing how filters might be extended.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            Initialise a new instance of NameAndSizeFilter.
            </summary>
            <param name="filter">The filter to apply.</param>
            <param name="minSize">The minimum file size to include.</param>
            <param name="maxSize">The maximum file size to include.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.IsMatch(System.String)">
            <summary>
            Test a filename to see if it matches the filter.
            </summary>
            <param name="name">The filename to test.</param>
            <returns>True if the filter matches, false otherwise.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.MinSize">
            <summary>
            Get/set the minimum size for a file that will match this filter.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Core.NameAndSizeFilter.MaxSize">
            <summary>
            Get/set the maximum size for a file that will match this filter.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.StreamUtils">
            <summary>
            Provides simple <see cref="T:System.IO.Stream"/>" utilities.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[])">
            <summary>
            Read from a <see cref="T:System.IO.Stream"/> ensuring all the required data is read.
            </summary>
            <param name="stream">The stream to read.</param>
            <param name="buffer">The buffer to fill.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from a <see cref="T:System.IO.Stream"/>" ensuring all the required data is read.
            </summary>
            <param name="stream">The stream to read data from.</param>
            <param name="buffer">The buffer to store data in.</param>
            <param name="offset">The offset at which to begin storing data.</param>
            <param name="count">The number of bytes of data to store.</param>
            <exception cref="T:System.ArgumentNullException">Required parameter is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> and or <paramref name="count"/> are invalid.</exception>
            <exception cref="T:System.IO.EndOfStreamException">End of stream is encountered before all the data has been read.</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[])">
            <summary>
            Copy the contents of one <see cref="T:System.IO.Stream"/> to another.
            </summary>
            <param name="source">The stream to source data from.</param>
            <param name="destination">The stream to write data to.</param>
            <param name="buffer">The buffer to use during copying.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[],ICSharpCode.SharpZipLib.Core.ProgressHandler,System.TimeSpan,System.Object,System.String)">
            <summary>
            Copy the contents of one <see cref="T:System.IO.Stream"/> to another.
            </summary>
            <param name="source">The stream to source data from.</param>
            <param name="destination">The stream to write data to.</param>
            <param name="buffer">The buffer to use during copying.</param>
            <param name="progressHandler">The <see cref="T:ICSharpCode.SharpZipLib.Core.ProgressHandler">progress handler delegate</see> to use.</param>
            <param name="updateInterval">The minimum <see cref="T:System.TimeSpan"/> between progress updates.</param>
            <param name="sender">The source for this event.</param>
            <param name="name">The name to use with the event.</param>
            <remarks>This form is specialised for use within #Zip to support events during archive operations.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[],ICSharpCode.SharpZipLib.Core.ProgressHandler,System.TimeSpan,System.Object,System.String,System.Int64)">
            <summary>
            Copy the contents of one <see cref="T:System.IO.Stream"/> to another.
            </summary>
            <param name="source">The stream to source data from.</param>
            <param name="destination">The stream to write data to.</param>
            <param name="buffer">The buffer to use during copying.</param>
            <param name="progressHandler">The <see cref="T:ICSharpCode.SharpZipLib.Core.ProgressHandler">progress handler delegate</see> to use.</param>
            <param name="updateInterval">The minimum <see cref="T:System.TimeSpan"/> between progress updates.</param>
            <param name="sender">The source for this event.</param>
            <param name="name">The name to use with the event.</param>
            <param name="fixedTarget">A predetermined fixed target value to use with progress updates.
            If the value is negative the target is calculated by looking at the stream.</param>
            <remarks>This form is specialised for use within #Zip to support events during archive operations.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.StreamUtils.#ctor">
            <summary>
            Initialise an instance of <see cref="T:ICSharpCode.SharpZipLib.Core.StreamUtils"></see>
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Core.WindowsPathUtils">
            <summary>
            WindowsPathUtils provides simple utilities for handling windows paths.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.WindowsPathUtils.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.SharpZipLib.Core.WindowsPathUtils"/> class.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Core.WindowsPathUtils.DropPathRoot(System.String)">
            <summary>
            Remove any path root present in the path
            </summary>
            <param name="path">A <see cref="T:System.String"/> containing path information.</param>
            <returns>The path with the root removed if it was present; path otherwise.</returns>
            <remarks>Unlike the <see cref="T:System.IO.Path"/> class the path isnt otherwise checked for validity.</remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassic">
            <summary>
            PkzipClassic embodies the classic or original encryption facilities used in Pkzip archives.
            While it has been superceded by more recent and more powerful algorithms, its still in use and 
            is viable for preventing casual snooping
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassic.GenerateKeys(System.Byte[])">
            <summary>
            Generates new encryption keys based on given seed
            </summary>
            <param name="seed">The seed value to initialise keys with.</param>
            <returns>A new key value.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase">
            <summary>
            PkzipClassicCryptoBase provides the low level facilities for encryption
            and decryption using the PkzipClassic algorithm.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase.TransformByte">
            <summary>
            Transform a single byte 
            </summary>
            <returns>
            The transformed value
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase.SetKeys(System.Byte[])">
            <summary>
            Set the key schedule for encryption/decryption.
            </summary>
            <param name="keyData">The data use to set the keys from.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase.UpdateKeys(System.Byte)">
            <summary>
            Update encryption keys 
            </summary>		
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicCryptoBase.Reset">
            <summary>
            Reset the internal state.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform">
            <summary>
            PkzipClassic CryptoTransform for encryption.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.#ctor(System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform"></see>
            </summary>
            <param name="keyBlock">The key block to use.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies 
            the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform">
            <summary>
            PkzipClassic CryptoTransform for decryption.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.#ctor(System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform"></see>.
            </summary>
            <param name="keyBlock">The key block to decrypt with.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies 
            the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged">
            <summary>
            Defines a wrapper object to access the Pkzip algorithm. 
            This class cannot be inherited.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.BlockSize">
            <summary>
            Get / set the applicable block size in bits.
            </summary>
            <remarks>The only valid block size is 8.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.LegalKeySizes">
            <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">key sizes.</see>
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.GenerateIV">
            <summary>
            Generate an initial vector.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.LegalBlockSizes">
            <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">block sizes</see>.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.Key">
            <summary>
            Get / set the key value applicable.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.GenerateKey">
            <summary>
            Generate a new random key.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>
            Create an encryptor.
            </summary>
            <param name="rgbKey">The key to use for this encryptor.</param>
            <param name="rgbIV">Initialisation vector for the new encryptor.</param>
            <returns>Returns a new PkzipClassic encryptor</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.PkzipClassicManaged.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>
            Create a decryptor.
            </summary>
            <param name="rgbKey">Keys to use for this new decryptor.</param>
            <param name="rgbIV">Initialisation vector for the new decryptor.</param>
            <returns>Returns a new decryptor.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform">
            <summary>
            Transforms stream using AES in CTR mode
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.#ctor(System.String,System.Byte[],System.Int32,System.Boolean)">
             <summary>
             Constructor.
             </summary>
             <param name="key">Password string</param>
             <param name="saltBytes">Random bytes, length depends on encryption strength.
             128 bits = 8 bytes, 192 bits = 12 bytes, 256 bits = 16 bytes.</param>
             <param name="blockSize">The encryption strength, in bytes eg 16 for 128 bits.</param>
             <param name="writeMode">True when creating a zip, false when reading. For the AuthCode.</param>
            
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Implement the ICryptoTransform method.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.PwdVerifier">
            <summary>
            Returns the 2 byte password verifier
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.GetAuthCode">
            <summary>
            Returns the 10 byte AUTH CODE to be checked or appended immediately following the AES data stream.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Encryption.ZipAESTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.GZip.GZip">
            <summary>
            An example class to demonstrate compression and decompression of GZip streams.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZip.Decompress(System.IO.Stream,System.IO.Stream,System.Boolean)">
            <summary>
            Decompress the <paramref name="inStream">input</paramref> writing 
            uncompressed data to the <paramref name="outStream">output stream</paramref>
            </summary>
            <param name="inStream">The readable stream containing data to decompress.</param>
            <param name="outStream">The output stream to receive the decompressed data.</param>
            <param name="isStreamOwner">Both streams are closed on completion if true.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZip.Compress(System.IO.Stream,System.IO.Stream,System.Boolean,System.Int32)">
            <summary>
            Compress the <paramref name="inStream">input stream</paramref> sending 
            result data to <paramref name="outStream">output stream</paramref>
            </summary>
            <param name="inStream">The readable stream to compress.</param>
            <param name="outStream">The output stream to receive the compressed data.</param>
            <param name="isStreamOwner">Both streams are closed on completion if true.</param>
            <param name="level">Block size acts as compression level (1 to 9) with 1 giving 
            the lowest compression and 9 the highest.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.GZip.GZipConstants">
            <summary>
            This class contains constants used for gzip.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.GZIP_MAGIC">
            <summary>
            Magic number found at start of GZIP header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FTEXT">
            <summary>
            Flag bit mask for text
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FHCRC">
            <summary>
            Flag bitmask for Crc
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FEXTRA">
            <summary>
            Flag bit mask for extra
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FNAME">
            <summary>
            flag bitmask for name
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipConstants.FCOMMENT">
            <summary>
            flag bit mask indicating comment is present
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipConstants.#ctor">
            <summary>
            Initialise default instance.
            </summary>
            <remarks>Constructor is private to prevent instances being created.</remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.GZip.GZipException">
            <summary>
            GZipException represents exceptions specific to GZip classes and code.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.GZip.GZipException" />.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.GZip.GZipException" /> with its message string.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipException.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.GZip.GZipException" />.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
            <param name="innerException">The <see cref="T:System.Exception"/> that caused this exception.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.GZip.GZipInputStream">
            <summary>
            This filter stream is used to decompress a "GZIP" format stream.
            The "GZIP" format is described baseInputStream RFC 1952.
            
            author of the original java version : John Leuner
            </summary>
            <example> This sample shows how to unzip a gzipped file
            <code>
            using System;
            using System.IO;
            
            using ICSharpCode.SharpZipLib.Core;
            using ICSharpCode.SharpZipLib.GZip;
            
            class MainClass
            {
            	public static void Main(string[] args)
            	{
            		using (Stream inStream = new GZipInputStream(File.OpenRead(args[0])))
            		using (FileStream outStream = File.Create(Path.GetFileNameWithoutExtension(args[0]))) {
            			byte[] buffer = new byte[4096];
            			StreamUtils.Copy(inStream, outStream, buffer);
            		}
            	}
            }	
            </code>
            </example>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipInputStream.crc">
            <summary>
            CRC-32 value for uncompressed data
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipInputStream.readGZIPHeader">
            <summary>
            Flag to indicate if we've read the GZIP header yet for the current member (block of compressed data).
            This is tracked per-block as the file is parsed.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipInputStream.completedLastBlock">
            <summary>
            Flag to indicate if at least one block in a stream with concatenated blocks was read successfully.
            This allows us to exit gracefully if downstream data is not in gzip format.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a GZipInputStream with the default buffer size
            </summary>
            <param name="baseInputStream">
            The stream to read compressed data from (baseInputStream GZIP format)
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a GZIPInputStream with the specified buffer size
            </summary>
            <param name="baseInputStream">
            The stream to read compressed data from (baseInputStream GZIP format)
            </param>
            <param name="size">
            Size of the buffer to use
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads uncompressed data into an array of bytes
            </summary>
            <param name="buffer">
            The buffer to read uncompressed data into
            </param>
            <param name="offset">
            The offset indicating where the data should be placed
            </param>
            <param name="count">
            The number of uncompressed bytes to be read
            </param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.GZip.GZipOutputStream">
             <summary>
             This filter stream is used to compress a stream into a "GZIP" stream.
             The "GZIP" format is described in RFC 1952.
            
             author of the original java version : John Leuner
             </summary>
             <example> This sample shows how to gzip a file
             <code>
             using System;
             using System.IO;
             
             using ICSharpCode.SharpZipLib.GZip;
             using ICSharpCode.SharpZipLib.Core;
             
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             			using (Stream s = new GZipOutputStream(File.Create(args[0] + ".gz")))
             			using (FileStream fs = File.OpenRead(args[0])) {
             				byte[] writeData = new byte[4096];
             				Streamutils.Copy(s, fs, writeData);
             			}
             		}
             	}
             }	
             </code>
             </example>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.crc">
            <summary>
            CRC-32 value for uncompressed data
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a GzipOutputStream with the default buffer size
            </summary>
            <param name="baseOutputStream">
            The stream to read data (to be compressed) from
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a GZipOutputStream with the specified buffer size
            </summary>
            <param name="baseOutputStream">
            The stream to read data (to be compressed) from
            </param>
            <param name="size">
            Size of the buffer to use
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.SetLevel(System.Int32)">
            <summary>
            Sets the active compression level (1-9).  The new level will be activated
            immediately.
            </summary>
            <param name="level">The compression level to set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Level specified is not supported.
            </exception>
            <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.GetLevel">
            <summary>
            Get the current compression level.
            </summary>
            <returns>The current compression level.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write given buffer to output updating crc
            </summary>
            <param name="buffer">Buffer to write</param>
            <param name="offset">Offset of first byte in buf to write</param>
            <param name="count">Number of bytes to write</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Dispose(System.Boolean)">
            <summary>
            Writes remaining compressed output data to the output stream
            and closes it.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.GZip.GZipOutputStream.Finish">
            <summary>
            Finish compression and write any footer information required to stream
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            <summary>
            SharpZipBaseException is the base exception class for SharpZipLib.
            All library exceptions are derived from this.
            </summary>
            <remarks>NOTE: Not all exceptions thrown will be derived from this class.
            A variety of other exceptions are possible for example <see cref="T:System.ArgumentNullException"></see></remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor">
            <summary>
            Initializes a new instance of the SharpZipBaseException class.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified error message.
            </summary>
            <param name="message">A message describing the exception.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.SharpZipBaseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message describing the exception.</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater">
             <summary>
             This is the Deflater class.  The deflater class compresses input
             with the deflate algorithm described in RFC 1951.  It has several
             compression levels and three different strategies described below.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of deflate and setInput.
             
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.BEST_COMPRESSION">
            <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.BEST_SPEED">
            <summary>
            The worst but fastest compression level.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.DEFAULT_COMPRESSION">
            <summary>
            The default compression level.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.NO_COMPRESSION">
            <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.DEFLATED">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.CompressionLevel">
            <summary>
            Compression Level as an enum for safer use
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.CompressionLevel.BEST_COMPRESSION">
            <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.CompressionLevel.BEST_SPEED">
            <summary>
            The worst but fastest compression level.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.CompressionLevel.DEFAULT_COMPRESSION">
            <summary>
            The default compression level.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.CompressionLevel.NO_COMPRESSION">
            <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.CompressionLevel.DEFLATED">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor">
            <summary>
            Creates a new deflater with default compression level.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION.
            </param>
            <param name="noZlibHeaderOrFooter">
            true, if we should suppress the Zlib/RFC1950 header at the
            beginning and the adler checksum at the end of the output.  This is
            useful for the GZIP/PKZIP formats.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Reset">
            <summary>
            Resets the deflater.  The deflater acts afterwards as if it was
            just created with the same compression level and strategy as it
            had before.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Adler">
            <summary>
            Gets the current adler checksum of the data that was processed so far.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalIn">
            <summary>
            Gets the number of input bytes processed so far.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.TotalOut">
            <summary>
            Gets the number of output bytes so far.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Flush">
            <summary>
            Flushes the current input block.  Further calls to deflate() will
            produce enough output to inflate everything in the current input
            block.  This is not part of Sun's JDK so I have made it package
            private.  It is used by DeflaterOutputStream to implement
            flush().
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Finish">
            <summary>
            Finishes the deflater with the current input block.  It is an error
            to give more input after this method was called.  This method must
            be called to force all bytes to be flushed.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsFinished">
            <summary>
            Returns true if the stream was finished and no more output bytes
            are available.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method can also return true when the stream
            was finished.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[])">
            <summary>
            Sets the data which should be compressed next.  This should be only
            called when needsInput indicates that more input is needed.
            If you call setInput when needsInput() returns false, the
            previous input that is still pending will be thrown away.
            The given byte array should not be changed, before needsInput() returns
            true again.
            This call is equivalent to <code>setInput(input, 0, input.length)</code>.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended().
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the data which should be compressed next.  This should be
            only called when needsInput indicates that more input is needed.
            The given byte array should not be changed, before needsInput() returns
            true again.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <param name="offset">
            the start of the data.
            </param>
            <param name="count">
            the number of data bytes of input.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was Finish()ed or if previous input is still pending.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  There is no guarantee of the exact
            position of the change, but if you call this when needsInput is
            true the change of compression level will occur somewhere near
            before the end of the so far given input.
            </summary>
            <param name="level">
            the new compression level.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.GetLevel">
            <summary>
            Get current compression level
            </summary>
            <returns>Returns the current compression level</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetStrategy(ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy)">
            <summary>
            Sets the compression strategy. Strategy is one of
            DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
            position where the strategy is changed, the same as for
            SetLevel() applies.
            </summary>
            <param name="strategy">
            The new compression strategy.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[])">
            <summary>
            Deflates the current input block with to the given array.
            </summary>
            <param name="output">
            The buffer where compressed data is stored
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            IsNeedingInput() or IsFinished returns true or length is zero.
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Deflates the current input block to the given array.
            </summary>
            <param name="output">
            Buffer to store the compressed data.
            </param>
            <param name="offset">
            Offset into the output array.
            </param>
            <param name="length">
            The maximum number of bytes that may be stored.
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If Finish() was previously called.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If offset or length don't match the array length.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
            </summary>
            <param name="dictionary">
            the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if SetInput () or Deflate () were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            The dictionary is a byte array containing strings that are
            likely to occur in the data which should be compressed.  The
            dictionary is not stored in the compressed output, only a
            checksum.  To decompress the output you need to supply the same
            dictionary again.
            </summary>
            <param name="dictionary">
            The dictionary data
            </param>
            <param name="index">
            The index where dictionary information commences.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If SetInput () or Deflate() were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.level">
            <summary>
            Compression level.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.noZlibHeaderOrFooter">
            <summary>
            If true no Zlib/RFC1950 headers or footers are generated
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.totalOut">
            <summary>
            The total bytes of output written.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.pending">
            <summary>
            The pending output.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Deflater.engine">
            <summary>
            The deflater engine.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants">
            <summary>
            This class contains constants used for deflation.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEBUGGING">
            <summary>
            Set to true to enable debugging
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.STORED_BLOCK">
            <summary>
            Written to Zip file to identify a stored block
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.STATIC_TREES">
            <summary>
            Identifies static tree in Zip file
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DYN_TREES">
            <summary>
            Identifies dynamic tree in Zip file
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.PRESET_DICT">
            <summary>
            Header flag indicating a preset dictionary for deflation
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFAULT_MEM_LEVEL">
            <summary>
            Sets internal buffer sizes for Huffman encoding
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_MATCH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_MATCH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_WBITS">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.WSIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.WMASK">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_BITS">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_MASK">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SHIFT">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_LOOKAHEAD">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_DIST">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.PENDING_BUF_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_BLOCK_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_STORED">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_FAST">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_SLOW">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.GOOD_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_LAZY">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.NICE_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_CHAIN">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterConstants.COMPR_FUNC">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy">
            <summary>
            Strategies for deflater
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.Default">
            <summary>
            The default strategy
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.Filtered">
            <summary>
            This strategy will only allow longer string repetitions.  It is
            useful for random data with a small character set.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy.HuffmanOnly">
            <summary>
            This strategy will not look for string repetitions at all.  It
            only encodes with Huffman trees (which means, that more common
            characters get a smaller encoding.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine">
            <summary>
            Low level compression engine for deflate algorithm which uses a 32K sliding window
            with secondary compression from Huffman/Shannon-Fano codes.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.#ctor(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">
            Pending buffer to use
            </param>>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
            <summary>
            Deflate drives actual compression of data
            </summary>
            <param name="flush">True to flush input buffers</param>
            <param name="finish">Finish deflation with the current input.</param>
            <returns>Returns true if progress has been made.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
            returns true
            </summary>
            <param name="buffer">The buffer containing input data.</param>
            <param name="offset">The offset of the first byte of data.</param>
            <param name="count">The number of bytes of data to use as input.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.NeedsInput">
            <summary>
            Determines if more <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">input</see> is needed.
            </summary>		
            <returns>Return true if input is needed via <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">SetInput</see></returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set compression dictionary
            </summary>
            <param name="buffer">The buffer containing the dictionary data</param>
            <param name="offset">The offset in the buffer for the first byte of data</param>
            <param name="length">The length of the dictionary data.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Reset">
            <summary>
            Reset internal state
            </summary>		
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.ResetAdler">
            <summary>
            Reset Adler checksum
            </summary>		
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Adler">
            <summary>
            Get current value of Adler checksum
            </summary>		
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.TotalIn">
            <summary>
            Total data processed
            </summary>		
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.Strategy">
            <summary>
            Get/set the <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflateStrategy">deflate strategy</see>
            </summary>		
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.SetLevel(System.Int32)">
            <summary>
            Set the deflate level (0-9)
            </summary>
            <param name="level">The value to set the level to.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.FillWindow">
            <summary>
            Fill the window
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.InsertString">
            <summary>
            Inserts the current string in the head hash and returns the previous
            value for this hash.
            </summary>
            <returns>The previous hash value</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.FindLongestMatch(System.Int32)">
             <summary>
             Find the best (longest) string in the window matching the 
             string starting at strstart.
            
             Preconditions:
             <code>
             strstart + DeflaterConstants.MAX_MATCH &lt;= window.length.</code>
             </summary>
             <param name="curMatch"></param>
             <returns>True if a match greater than the minimum length is found</returns>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.head">
            <summary>
            Hashtable, hashing three characters to an index for window, so
            that window[index]..window[index+2] have this hash code.  
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.prev">
            <summary>
            <code>prev[index &amp; WMASK]</code> points to the previous index that has the
            same hash code as the string starting at index.  This way 
            entries with the same hash code are in a linked list.
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.strstart">
            <summary>
            Points to the current character in the window.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.lookahead">
            <summary>
            lookahead is the number of characters starting at strstart in
            window that are valid.
            So window[strstart] until window[strstart+lookahead-1] are valid
            characters.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.window">
            <summary>
            This array contains the part of the uncompressed stream that 
            is of relevance.  The current character is indexed by strstart.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.compressionFunction">
            <summary>
            The current compression function.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.inputBuf">
            <summary>
            The input data for compression.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.totalIn">
            <summary>
            The total bytes of input read.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.inputOff">
            <summary>
            The offset into inputBuf, where input data starts.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.inputEnd">
            <summary>
            The end offset of the input data.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine.adler">
            <summary>
            The adler checksum
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman">
            <summary>
            This is the DeflaterHuffman class.
            
            This class is <i>not</i> thread safe.  This is inherent in the API, due
            to the split of Deflate and SetInput.
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.Reset">
            <summary>
            Resets the internal state of the tree
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CheckEmpty">
            <summary>
            Check that all frequencies are zero
            </summary>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            At least one frequency is non-zero
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.SetStaticCodes(System.Int16[],System.Byte[])">
            <summary>
            Set static codes and length
            </summary>
            <param name="staticCodes">new codes</param>
            <param name="staticLengths">length for new codes</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.BuildCodes">
            <summary>
            Build dynamic codes and lengths
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.GetEncodedLength">
            <summary>
            Get encoded length
            </summary>
            <returns>Encoded length, the sum of frequencies * lengths</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CalcBLFreq(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Scan a literal or distance tree to determine the frequencies of the codes
            in the bit length tree.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.WriteTree(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Write tree values
            </summary>
            <param name="blTree">Tree to write</param>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.pending">
            <summary>
            Pending buffer to use
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.#ctor(ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">Pending buffer to use</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.Reset">
            <summary>
            Reset internal state
            </summary>		
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.SendAllTrees(System.Int32)">
            <summary>
            Write all trees to pending buffer
            </summary>
            <param name="blTreeCodes">The number/rank of treecodes to send.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.CompressBlock">
            <summary>
            Compress current buffer writing data to pending buffer
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with no compression
            </summary>
            <param name="stored">Data to write</param>
            <param name="storedOffset">Index of first byte to write</param>
            <param name="storedLength">Count of bytes to write</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with compression
            </summary>		
            <param name="stored">Data to flush</param>
            <param name="storedOffset">Index of first byte to flush</param>
            <param name="storedLength">Count of bytes to flush</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.IsFull">
            <summary>
            Get value indicating if internal buffer is full
            </summary>
            <returns>true if buffer is full</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyLit(System.Int32)">
            <summary>
            Add literal to buffer
            </summary>
            <param name="literal">Literal value to add to buffer.</param>
            <returns>Value indicating internal buffer is full</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
            <summary>
            Add distance code and length to literal and distance trees
            </summary>
            <param name="distance">Distance code</param>
            <param name="length">Length</param>
            <returns>Value indicating if internal buffer is full</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterHuffman.BitReverse(System.Int32)">
            <summary>
            Reverse the bits of a 16 bit value.
            </summary>
            <param name="toReverse">Value to reverse bits</param>
            <returns>Value with bits reversed</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending">
            <summary>
            This class stores the pending output of the Deflater.
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.DeflaterPending.#ctor">
            <summary>
            Construct instance with default buffer size
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Inflater">
             <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
             
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul>
             <li>IsNeedingInput() returns true because the input buffer is empty.
             You have to provide more input with <code>SetInput()</code>.
             NOTE: IsNeedingInput() also returns true when, the stream is finished.
             </li>
             <li>IsNeedingDictionary() returns true, you have to provide a preset
                dictionary with <code>SetDictionary()</code>.</li>
             <li>IsFinished returns true, the inflater has finished.</li>
             </ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             author of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.CPLENS">
            <summary>
            Copy lengths for literal codes 257..285
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.CPLEXT">
            <summary>
            Extra bits for literal codes 257..285
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.CPDIST">
            <summary>
            Copy offsets for distance codes 0..29
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.CPDEXT">
            <summary>
            Extra bits for distance codes
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DECODE_HEADER">
            <summary>
            These are the possible states for an inflater
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.mode">
            <summary>
            This variable contains the current state.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.readAdler">
            <summary>
            The adler checksum of the dictionary or of the decompressed
            stream, as it is written in the header resp. footer of the
            compressed stream. 
            Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.neededBits">
            <summary>
            The number of bits needed to complete the current state.  This
            is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
            DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.isLastBlock">
            <summary>
            True, if the last block flag was set in the last block of the
            inflated stream.  This means that the stream ends after the
            current block.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.totalOut">
            <summary>
            The total number of inflated bytes.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.totalIn">
            <summary>
            The total number of bytes set with setInput().  This is not the
            value returned by the TotalIn property, since this also includes the
            unprocessed input.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.noHeader">
            <summary>
            This variable stores the noHeader flag that was given to the constructor.
            True means, that the inflated stream doesn't contain a Zlib header or 
            footer.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.#ctor">
            <summary>
            Creates a new inflater or RFC1951 decompressor
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.#ctor(System.Boolean)">
            <summary>
            Creates a new inflater.
            </summary>
            <param name="noHeader">
            True if no RFC1950/Zlib header and footer fields are expected in the input data
            
            This is used for GZIPed/Zipped input.
            
            For compatibility with
            Sun JDK you should provide one byte of input more than needed in
            this case.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Reset">
            <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DecodeHeader">
            <summary>
            Decodes a zlib/RFC1950 header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            The header is invalid.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DecodeDict">
            <summary>
            Decodes the dictionary checksum after the deflate header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DecodeHuffman">
            <summary>
            Decodes the huffman encoded symbols in the input stream.
            </summary>
            <returns>
            false if more input is needed, true if output window is
            full or the current block ends.
            </returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.DecodeChksum">
            <summary>
            Decodes the adler checksum after the deflate stream.
            </summary>
            <returns>
            false if more input is needed.
            </returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            If checksum doesn't match.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Decode">
            <summary>
            Decodes the deflated stream.
            </summary>
            <returns>
            false if more input is needed, or if finished.
            </returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
            <param name="index">
            The index into buffer where the dictionary starts.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            The adler checksum for the buffer is invalid
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[])">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            the input.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            The source of input data
            </param>
            <param name="index">
            The index into buffer where the input starts.
            </param>
            <param name="count">
            The number of bytes of input to use.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The index and/or count are wrong.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[])">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether IsNeedingDictionary(),
            IsNeedingInput() or IsFinished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <returns>
            The number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if buffer has length 0.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <param name="offset">
            the offset in buffer where storing starts.
            </param>
            <param name="count">
            the maximum number of bytes to output.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if the index and / or count are wrong.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method also returns true when the stream is finished.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsNeedingDictionary">
            <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.IsFinished">
            <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.Adler">
            <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
            <returns>
            the adler checksum.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.TotalOut">
            <summary>
            Gets the total number of output bytes returned by Inflate().
            </summary>
            <returns>
            the total number of output bytes.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.TotalIn">
            <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
            <returns>
            The total number of bytes of processed input bytes.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.RemainingInput">
            <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
            <returns>
            The number of bytes of the input which have not been processed.
            </returns>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.InflaterDynHeader.mode">
            <summary>
            The current decode mode
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree">
            <summary>
            Huffman tree used for inflation
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defLitLenTree">
            <summary>
            Literal length tree
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defDistTree">
            <summary>
            Distance tree
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.#ctor(System.Byte[])">
            <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
            <param name = "codeLengths">
            the array of code lengths
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree.GetSymbol(ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator)">
            <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
            <param name="input">
            input the input source.
            </param>
            <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer">
            <summary>
            This class is general purpose class for writing data to a buffer.
            
            It allows you to write bits as well as bytes
            Based on DeflaterPending.java
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.buffer">
            <summary>
            Internal work buffer
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.#ctor">
            <summary>
            construct instance using default buffer size of 4096
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.#ctor(System.Int32)">
            <summary>
            construct instance using specified buffer size
            </summary>
            <param name="bufferSize">
            size to use for internal buffer
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.Reset">
            <summary>
            Clear internal state/buffers
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteByte(System.Int32)">
            <summary>
            Write a byte to buffer
            </summary>
            <param name="value">
            The value to write
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteShort(System.Int32)">
            <summary>
            Write a short value to buffer LSB first
            </summary>
            <param name="value">
            The value to write.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteInt(System.Int32)">
            <summary>
            write an integer LSB first
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a block of data to buffer
            </summary>
            <param name="block">data to write</param>
            <param name="offset">offset of first byte to write</param>
            <param name="length">number of bytes to write</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.BitCount">
            <summary>
            The number of bits written to the buffer
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.AlignToByte">
            <summary>
            Align internal buffer on a byte boundary
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteBits(System.Int32,System.Int32)">
            <summary>
            Write bits to internal buffer
            </summary>
            <param name="b">source of bits</param>
            <param name="count">number of bits to write</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.WriteShortMSB(System.Int32)">
            <summary>
            Write a short value to internal buffer most significant byte first
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.IsFlushed">
            <summary>
            Indicates if buffer has been flushed
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Flushes the pending buffer into the given output array.  If the
            output array is to small, only a partial flush is done.
            </summary>
            <param name="output">The output array.</param>
            <param name="offset">The offset into output array.</param>
            <param name="length">The maximum number of bytes to store.</param>
            <returns>The number of bytes flushed.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer.ToByteArray">
            <summary>
            Convert internal buffer to byte array.
            Buffer is empty on completion
            </summary>
            <returns>
            The internal buffer contents converted to a byte array.
            </returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream">
            <summary>
            A special stream deflating or compressing the bytes that are
            written to it.  It uses a Deflater to perform actual deflating.<br/>
            Authors of the original java version : Tom Tromey, Jochen Hoenicke 
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Deflater)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
            <param name="deflater">
            the underlying deflater.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Deflater,System.Int32)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            buffer size.
            </summary>
            <param name="baseOutputStream">
            The output stream where deflated output is written.
            </param>
            <param name="deflater">
            The underlying deflater to use
            </param>
            <param name="bufferSize">
            The buffer size in bytes to use when deflating (minimum value 512)
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            bufsize is less than or equal to zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            baseOutputStream does not support writing
            </exception>
            <exception cref="T:System.ArgumentNullException">
            deflater instance is null
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish">
            <summary>
            Finishes the stream by calling finish() on the deflater. 
            </summary>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Not all input is deflated
            </exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner">
            <summary>
            Gets or sets a flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:System.IO.Stream.Dispose" /> will close the underlying stream also.
            </summary>
            <remarks>The default value is true.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanPatchEntries">
            <summary>
            Allows client to determine if an entry can be patched after its added
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.AESAuthCode">
            <summary>
            Returns the 10 byte AUTH CODE to be appended immediately following the AES data stream.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Password">
            <summary>
            Get/set the password used for encryption.
            </summary>
            <remarks>When set to null or if the password is empty no encryption is performed</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.EncryptBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypt a block of data
            </summary>
            <param name="buffer">
            Data to encrypt.  NOTE the original contents of the buffer are lost
            </param>
            <param name="offset">
            Offset of first byte in buffer to encrypt
            </param>
            <param name="length">
            Number of bytes in buffer to encrypt
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.InitializePassword(System.String)">
            <summary>
            Initializes encryption keys based on given <paramref name="password"/>.
            </summary>
            <param name="password">The password.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.InitializeAESPassword(ICSharpCode.SharpZipLib.Zip.ZipEntry,System.String,System.Byte[]@,System.Byte[]@)">
            <summary>
            Initializes encryption keys based on given password.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Deflate">
            <summary>
            Deflates everything in the input buffers.  This will call
            <code>def.deflate()</code> until all bytes from the input buffers
            are processed.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanRead">
            <summary>
            Gets value indicating stream can be read from
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanSeek">
            <summary>
            Gets a value indicating if seeking is supported for this stream
            This property always returns false
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanWrite">
            <summary>
            Get value indicating if this stream supports writing
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Length">
            <summary>
            Get current length of stream
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Position">
            <summary>
            Gets the current position within the stream.
            </summary>
            <exception cref="T:System.NotSupportedException">Any attempt to set position</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position of this stream to the given value. Not supported by this class!
            </summary>
            <param name="offset">The offset relative to the <paramref name="origin"/> to seek.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of this stream to the given value. Not supported by this class!
            </summary>
            <param name="value">The new stream length.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.ReadByte">
            <summary>
            Read a byte from stream advancing position by one
            </summary>
            <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from stream
            </summary>
            <param name="buffer">The buffer to store read data in.</param>
            <param name="offset">The offset to start storing at.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">
            <summary>
            Flushes the stream by calling <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">Flush</see> on the deflater and then
            on the underlying stream.  This ensures that all bytes are flushed.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Dispose(System.Boolean)">
            <summary>
            Calls <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish"/> and closes the underlying
            stream when <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner"></see> is true.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the compressed output stream.
            </summary>
            <param name="value">
            The byte value.
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes from an array to the compressed stream.
            </summary>
            <param name="buffer">
            The byte array
            </param>
            <param name="offset">
            The offset into the byte array where to start.
            </param>
            <param name="count">
            The number of bytes to write.
            </param>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.buffer_">
            <summary>
            This buffer is used temporarily to retrieve the bytes from the
            deflater and write them to the underlying output stream.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.deflater_">
            <summary>
            The deflater which is used to deflate the stream.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.baseOutputStream_">
            <summary>
            Base stream the deflater depends on.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">
            <summary>
            An input buffer customised for use by <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            </summary>
            <remarks>
            The buffer supports decryption of incoming data.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/> with a default buffer size
            </summary>
            <param name="stream">The stream to buffer.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/>
            </summary>
            <param name="stream">The stream to buffer.</param>
            <param name="bufferSize">The size to use for the buffer</param>
            <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawLength">
            <summary>
            Get the length of bytes bytes in the <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData"/>
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData">
            <summary>
            Get the contents of the raw data buffer.
            </summary>
            <remarks>This may contain encrypted data.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearTextLength">
            <summary>
            Get the number of useable bytes in <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText"/>
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText">
            <summary>
            Get the contents of the clear text buffer.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Available">
            <summary>
            Get/set the number of bytes available
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.SetInflaterInput(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Call <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)"/> passing the current clear text buffer contents.
            </summary>
            <param name="inflater">The inflater to set input for.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Fill">
            <summary>
            Fill the buffer from the underlying input stream.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="buffer">The buffer to fill</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="outBuffer">The buffer to read into</param>
            <param name="offset">The offset to start reading data into.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read clear text data from the input stream.
            </summary>
            <param name="outBuffer">The buffer to add data to.</param>
            <param name="offset">The offset to start adding data at.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeByte">
            <summary>
            Read a <see cref="T:System.Byte"/> from the input stream.
            </summary>
            <returns>Returns the byte read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeShort">
            <summary>
            Read an <see cref="T:System.Int16"/> in little endian byte order.
            </summary>
            <returns>The short value read case to an int.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeInt">
            <summary>
            Read an <see cref="T:System.Int32"/> in little endian byte order.
            </summary>
            <returns>The int value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeLong">
            <summary>
            Read a <see cref="T:System.Int64"/> in little endian byte order.
            </summary>
            <returns>The long value read.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.CryptoTransform">
            <summary>
            Get/set the <see cref="T:System.Security.Cryptography.ICryptoTransform"/> to apply to any data.
            </summary>
            <remarks>Set this value to null to have no transform applied.</remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream">
             <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             This stream may form the basis for other decompression filters, such
             as the <see cref="T:ICSharpCode.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
            
             Author of the original java version : John Leuner.
             </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
            <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The source of input data
            </param>
            <param name = "inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater,System.Int32)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and the specified buffer size.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
            <param name = "inflater">
            The decompressor to use
            </param>
            <param name = "bufferSize">
            Size of the buffer to use
            </param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
            <summary>
            Gets or sets a flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:System.IO.Stream.Dispose" /> will close the underlying stream also.
            </summary>
            <remarks>The default value is true.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
            <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
            <param name ="count">
            Number of bytes to skip
            </param>
            <returns>
            The number of bytes skipped, zero if the end of 
            stream has been reached
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count">The number of bytes</paramref> to skip is less than or equal to zero.
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.StopDecrypting">
            <summary>
            Clear any cryptographic state.
            </summary>		
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Available">
            <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Fill">
            <summary>
            Fills the buffer with more data to decompress.
            </summary>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Stream ends early
            </exception>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanSeek">
            <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanWrite">
            <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Length">
            <summary>
            A value representing the length of the stream in bytes.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Position">
            <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
            <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Flush">
            <summary>
            Flushes the baseInputStream
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="offset">The relative offset to seek to.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> defining where to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
            <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="value">The new length value for the stream.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
            <param name="buffer">Thew buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
            <param name="value">The byte to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Dispose(System.Boolean)">
            <summary>
            Closes the input stream.  When <see cref="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner"></see>
            is true the underlying stream is also closed.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads decompressed data into the provided buffer byte array
            </summary>
            <param name ="buffer">
            The array to read and decompress data into
            </param>
            <param name ="offset">
            The offset indicating where the data should be placed
            </param>
            <param name ="count">
            The number of bytes to decompress
            </param>
            <returns>The number of bytes read.  Zero signals the end of stream</returns>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inf">
            <summary>
            Decompressor for this stream
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inputBuffer">
            <summary>
            <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">Input buffer</see> for this stream.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.baseInputStream">
            <summary>
            Base stream the inflater reads from.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.csize">
            <summary>
            The compressed size
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isClosed">
            <summary>
            Flag indicating wether this instance has been closed or not.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow">
            <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br/>
            Author of the original java version : John Leuner
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
            <summary>
            Write a byte to this output window
            </summary>
            <param name="value">value to write</param>
            <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
            <summary>
            Append a byte pattern already in the window itself
            </summary>
            <param name="length">length of pattern to copy</param>
            <param name="distance">distance from end of window pattern occurs</param>
            <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyStored(ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator,System.Int32)">
            <summary>
            Copy from input manipulator to internal window
            </summary>
            <param name="input">source of data</param>
            <param name="length">length of data to copy</param>
            <returns>the number of bytes copied</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy dictionary to window
            </summary>
            <param name="dictionary">source dictionary</param>
            <param name="offset">offset of start in source dictionary</param>
            <param name="length">length of dictionary</param>
            <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
            <summary>
            Get remaining unfilled space in window
            </summary>
            <returns>Number of bytes left in window</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">
            <summary>
            Get bytes available for output in window
            </summary>
            <returns>Number of bytes filled</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy contents of window to output
            </summary>
            <param name="output">buffer to copy to</param>
            <param name="offset">offset to start at</param>
            <param name="len">number of bytes to count</param>
            <returns>The number of bytes copied</returns>
            <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.Reset">
            <summary>
            Reset by clearing window so <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator">
             <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             authors of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
            <summary>
            Get the next sequence of bits but don't increase input pointer.  bitCount must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
            <param name="bitCount">The number of bits to peek.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
            <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
            <param name="bitCount">The number of bits to drop.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
            <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)"/> followed by <see cref="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)"/>, except for correct error handling.
            </summary>
            <param name="bitCount">The number of bits to retrieve.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits">
            <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
            <returns>
            the number of bits available.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
            <summary>
            Gets the number of bytes available.
            </summary>
            <returns>
            The number of bytes available.
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
            <summary>
            Skips to the next byte boundary.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
            <summary>
            Returns true when SetInput can be called
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
            <param name="output">
            The buffer to copy bytes to.
            </param>
            <param name="offset">
            The offset in the buffer at which copying starts
            </param>
            <param name="length">
            The length to copy, 0 is allowed.
            </param>
            <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset">
            <summary>
            Resets state and empties internal buffers
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
            <param name="buffer">data to be input</param>
            <param name="offset">offset of first byte of input</param>
            <param name="count">number of bytes of input to add.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.DescriptorData">
            <summary>
            Holds data pertinent to a data descriptor.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.CompressedSize">
            <summary>
            Get /set the compressed size of data.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.Size">
            <summary>
            Get / set the uncompressed size of data
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.DescriptorData.Crc">
            <summary>
            Get /set the crc value.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipHelperStream">
            <summary>
            This class assists with writing/reading from Zip files.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.#ctor(System.String)">
            <summary>
            Initialise an instance of this class.
            </summary>
            <param name="name">The name of the file to open.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipHelperStream"/>.
            </summary>
            <param name="stream">The stream to use.</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.IsStreamOwner">
            <summary>
            Get / set a value indicating wether the the underlying stream is owned or not.
            </summary>
            <remarks>If the stream is owned it is closed when this instance is closed.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.Dispose(System.Boolean)">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            The underlying stream is closed only if <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.IsStreamOwner"/> is true.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.LocateBlockWithSignature(System.Int32,System.Int64,System.Int32,System.Int32)">
            <summary>
            Locates a block with the desired <paramref name="signature"/>.
            </summary>
            <param name="signature">The signature to find.</param>
            <param name="endLocation">Location, marking the end of block.</param>
            <param name="minimumBlockSize">Minimum size of the block.</param>
            <param name="maximumVariableData">The maximum variable data.</param>
            <returns>Eeturns the offset of the first byte after the signature; -1 if not found</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteZip64EndOfCentralDirectory(System.Int64,System.Int64,System.Int64)">
            <summary>
            Write Zip64 end of central directory records (File header and locator).
            </summary>
            <param name="noOfEntries">The number of entries in the central directory.</param>
            <param name="sizeEntries">The size of entries in the central directory.</param>
            <param name="centralDirOffset">The offset of the dentral directory.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteEndOfCentralDirectory(System.Int64,System.Int64,System.Int64,System.Byte[])">
            <summary>
            Write the required records to end the central directory.
            </summary>
            <param name="noOfEntries">The number of entries in the directory.</param>
            <param name="sizeEntries">The size of the entries in the directory.</param>
            <param name="startOfCentralDirectory">The start of the central directory.</param>
            <param name="comment">The archive comment.  (This can be null).</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.ReadLEShort">
            <summary>
            Read an unsigned short in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.ReadLEInt">
            <summary>
            Read an int in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.ReadLELong">
            <summary>
            Read a long in little endian byte order.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEShort(System.Int32)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEUshort(System.UInt16)">
            <summary>
            Write a ushort in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEUint(System.UInt32)">
            <summary>
            Write a uint in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLELong(System.Int64)">
            <summary>
            Write a long in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteLEUlong(System.UInt64)">
            <summary>
            Write a ulong in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.WriteDataDescriptor(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Write a data descriptor.
            </summary>
            <param name="entry">The entry to write a descriptor for.</param>
            <returns>Returns the number of descriptor bytes written.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipHelperStream.ReadDataDescriptor(System.Boolean,ICSharpCode.SharpZipLib.Zip.DescriptorData)">
            <summary>
            Read data descriptor at the end of compressed data.
            </summary>
            <param name="zip64">if set to <c>true</c> [zip64].</param>
            <param name="data">The data to fill in.</param>
            <returns>Returns the number of bytes read in the descriptor.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.UseZip64">
            <summary>
            Determines how entries are tested to see if they should use Zip64 extensions or not.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.Off">
            <summary>
            Zip64 will not be forced on entries during processing.
            </summary>
            <remarks>An entry can have this overridden if required <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ForceZip64"></see></remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.On">
            <summary>
            Zip64 should always be used.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.UseZip64.Dynamic">
            <summary>
            #ZipLib will determine use based on entry values when added to archive.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.CompressionMethod">
            <summary>
            The kind of compression used for an entry in an archive
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored">
            <summary>
            A direct copy of the file contents is held in the archive
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated">
            <summary>
            Common Zip compression method using a sliding dictionary 
            of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflate64">
            <summary>
            An extension to deflate with a 64KB window. Not supported by #Zip currently
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.BZip2">
            <summary>
            BZip2 compression. Not supported by #Zip.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.WinZipAES">
            <summary>
            WinZip special for AES encryption, Now supported by #Zip.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm">
            <summary>
            Identifies the encryption algorithm used for an entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption has been used.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.PkzipClassic">
            <summary>
            Encrypted using PKZIP 2.0 or 'classic' encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Des">
            <summary>
            DES encryption has been used.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC2">
            <summary>
            RC2 encryption has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes168">
            <summary>
            Triple DES encryption with 168 bit keys has been used for this entry.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes112">
            <summary>
            Triple DES with 112 bit keys has been used for this entry.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes128">
            <summary>
            AES 128 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes192">
            <summary>
            AES 192 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Aes256">
            <summary>
            AES 256 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC2Corrected">
            <summary>
            RC2 corrected has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Blowfish">
            <summary>
            Blowfish has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Twofish">
            <summary>
            Twofish has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.RC4">
            <summary>
            RC4 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.EncryptionAlgorithm.Unknown">
            <summary>
            An unknown algorithm has been used for encryption.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags">
            <summary>
            Defines the contents of the general bit flags field for an archive entry.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Encrypted">
            <summary>
            Bit 0 if set indicates that the file is encrypted
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Method">
            <summary>
            Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Descriptor">
            <summary>
            Bit 3 if set indicates a trailing data desciptor is appended to the entry data
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPKware4">
            <summary>
            Bit 4 is reserved for use with method 8 for enhanced deflation
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Patched">
            <summary>
            Bit 5 if set indicates the file contains Pkzip compressed patched data.
            Requires version 2.7 or greater.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.StrongEncryption">
            <summary>
            Bit 6 if set indicates strong encryption has been used for this entry.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused7">
            <summary>
            Bit 7 is currently unused
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused8">
            <summary>
            Bit 8 is currently unused
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused9">
            <summary>
            Bit 9 is currently unused
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.Unused10">
            <summary>
            Bit 10 is currently unused
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.UnicodeText">
            <summary>
            Bit 11 if set indicates the filename and 
            comment fields for this file must be encoded using UTF-8.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.EnhancedCompress">
            <summary>
            Bit 12 is documented as being reserved by PKware for enhanced compression.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.HeaderMasked">
            <summary>
            Bit 13 if set indicates that values in the local header are masked to hide
            their actual values, and the central directory is encrypted.
            </summary>
            <remarks>
            Used when encrypting the central directory contents.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware14">
            <summary>
            Bit 14 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware15">
            <summary>
            Bit 15 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipConstants">
            <summary>
            This class contains constants used for Zip format files
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionMadeBy">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress"/>.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_MADE_BY">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See ZipInputStream.CanDecompressEntry.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionStrongEncryption">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_STRONG_ENCRYPTION">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VERSION_AES">
            <summary>
            Version indicating AES encryption
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.VersionZip64">
            <summary>
            The version required for Zip64 extensions (4.5 or higher)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LocalHeaderBaseSize">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LOCHDR">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64DataDescriptorSize">
            <summary>
            Size of Zip64 data descriptor
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.DataDescriptorSize">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EXTHDR">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderBaseSize">
            <summary>
            Size of central header entry (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENHDR">
            <summary>
            Size of central header entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EndOfCentralRecordBaseSize">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ENDHDR">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CryptoHeaderSize">
            <summary>
            Size of 'classic' cryptographic header stored before any entry data
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CRYPTO_HEADER_SIZE">
            <summary>
            Size of cryptographic header stored before entry data
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LocalHeaderSignature">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.LOCSIG">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SpanningSignature">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SPANNINGSIG">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SpanningTempSignature">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.SPANTEMPSIG">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.DataDescriptorSignature">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EXTSIG">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENSIG">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderSignature">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64CentralFileHeaderSignature">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENSIG64">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.Zip64CentralDirLocatorSignature">
            <summary>
            Signature for Zip64 central directory locator
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ArchiveExtraDataSignature">
            <summary>
            Signature for archive extra data signature (were headers are encrypted).
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CentralHeaderDigitalSignature">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.CENDIGITALSIG">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.EndOfCentralDirectorySignature">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.ENDSIG">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ZipConstants.defaultCodePage">
            <remarks>
            The original Zip specification (https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT) states 
            that file names should only be encoded with IBM Code Page 437 or UTF-8. 
            In practice, most zip apps use OEM or system encoding (typically cp437 on Windows). 
            Let's be good citizens and default to UTF-8 http://utf8everywhere.org/
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipConstants.DefaultCodePage">
            <summary>
            Default encoding used for string conversion.  0 gives the default system OEM code page.
            Using the default code page isnt the full solution neccessarily
            there are many variable factors, codepage 850 is often a good choice for
            European users, however be careful about compatability.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
            <summary>
            Convert a portion of a byte array to a string.
            </summary>		
            <param name="data">
            Data to convert to string
            </param>
            <param name="count">
            Number of bytes to convert starting from index 0
            </param>
            <returns>
            data[0]..data[count - 1] converted to a string
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="data">
            Byte array to convert
            </param>
            <param name="count">The number of bytes to convert.</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <param name="flags">The applicable general purpose bits flags</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.Int32,System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="flags">The applicable <see cref="T:ICSharpCode.SharpZipLib.Zip.GeneralBitFlags">general purpose bits flags</see></param>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipConstants.#ctor">
            <summary>
            Initialise default instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipConstants">ZipConstants</see>
            </summary>
            <remarks>
            Private to prevent instances being created.
            </remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.HostSystemID">
            <summary>
            Defines known values for the <see cref="T:ICSharpCode.SharpZipLib.Zip.HostSystemID"/> property.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Msdos">
            <summary>
            Host system = MSDOS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Amiga">
            <summary>
            Host system = Amiga
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OpenVms">
            <summary>
            Host system = Open VMS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Unix">
            <summary>
            Host system = Unix
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.VMCms">
            <summary>
            Host system = VMCms
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AtariST">
            <summary>
            Host system = Atari ST
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OS2">
            <summary>
            Host system = OS2
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Macintosh">
            <summary>
            Host system = Macintosh
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.ZSystem">
            <summary>
            Host system = ZSystem
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Cpm">
            <summary>
            Host system = Cpm
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.WindowsNT">
            <summary>
            Host system = Windows NT
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.MVS">
            <summary>
            Host system = MVS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Vse">
            <summary>
            Host system = VSE
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AcornRisc">
            <summary>
            Host system = Acorn RISC
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Vfat">
            <summary>
            Host system = VFAT
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.AlternateMvs">
            <summary>
            Host system = Alternate MVS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.BeOS">
            <summary>
            Host system = BEOS
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.Tandem">
            <summary>
            Host system = Tandem
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OS400">
            <summary>
            Host system = OS400
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.OSX">
            <summary>
            Host system = OSX
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.HostSystemID.WinZipAES">
            <summary>
            Host system = WinZIP AES
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipEntry">
            <summary>
            This class represents an entry in a zip archive.  This can be a file
            or a directory
            ZipFile and ZipInputStream will give you instances of this class as 
            information about the members in an archive.  ZipOutputStream
            uses an instance of this class when creating an entry in a Zip file.
            <br/>
            <br/>Author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(System.String)">
            <summary>
            Creates a zip entry with the given name.
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix' style paths with relative names only.
            There are with no device names and path elements are separated by '/' characters.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(System.String,System.Int32)">
            <summary>
            Creates a zip entry with the given name and version required to extract
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix'  style paths with no device names and 
            path elements separated by '/' characters.  This is not enforced see <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">CleanName</see>
            on how to ensure names are valid if this is desired.
            </param>
            <param name="versionRequiredToExtract">
            The minimum 'feature version' required this entry
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(System.String,System.Int32,System.Int32,ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Initializes an entry with the given name and made by information
            </summary>
            <param name="name">Name for this entry</param>
            <param name="madeByInfo">Version and HostSystem Information</param>
            <param name="versionRequiredToExtract">Minimum required zip feature version required to extract this entry</param>
            <param name="method">Compression method for this entry.</param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            versionRequiredToExtract should be 0 (auto-calculate) or > 10
            </exception>
            <remarks>
            This constructor is used by the ZipFile class when reading from the central header
            It is not generally useful, use the constructor specifying the name only.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.#ctor(ICSharpCode.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Creates a deep copy of the given zip entry.
            </summary>
            <param name="entry">
            The entry to copy.
            </param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HasCrc">
            <summary>
            Get a value indicating wether the entry has a CRC value available.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCrypted">
            <summary>
            Get/Set flag indicating if entry is encrypted.
            A simple helper routine to aid interpretation of <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see>
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsUnicodeText">
            <summary>
            Get / set a flag indicating wether entry name and comment text are
            encoded in <a href="http://www.unicode.org">unicode UTF8</a>.
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CryptoCheckValue">
            <summary>
            Value used during password checking for PKZIP 2.0 / 'classic' encryption.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Flags">
            <summary>
            Get/Set general purpose bit flag for entry
            </summary>
            <remarks>
            General purpose bit flag<br/>
            <br/>
            Bit 0: If set, indicates the file is encrypted<br/>
            Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br/>
            Imploding:<br/>
            Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br/>
            Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br/>
            <br/>
            Deflating:<br/>
              Bit 2    Bit 1<br/>
                0        0       Normal compression was used<br/>
                0        1       Maximum compression was used<br/>
                1        0       Fast compression was used<br/>
                1        1       Super fast compression was used<br/>
            <br/>
            Bit 3: If set, the fields crc-32, compressed size
            and uncompressed size are were not able to be written during zip file creation
            The correct values are held in a data descriptor immediately following the compressed data. <br/>
            Bit 4: Reserved for use by PKZIP for enhanced deflating<br/>
            Bit 5: If set indicates the file contains compressed patch data<br/>
            Bit 6: If set indicates strong encryption was used.<br/>
            Bit 7-10: Unused or reserved<br/>
            Bit 11: If set the name and comments for this entry are in <a href="http://www.unicode.org">unicode</a>.<br/>
            Bit 12-15: Unused or reserved<br/>
            </remarks>
            <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsUnicodeText"></seealso>
            <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCrypted"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ZipFileIndex">
            <summary>
            Get/Set index of this entry in Zip file
            </summary>
            <remarks>This is only valid when the entry is part of a ZipFile</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Offset">
            <summary>
            Get/set offset for use in central header
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">
            <summary>
            Get/Set external file attributes as an integer.
            The values of this are operating system dependant see
            <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HostSystem">HostSystem</see> for details
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.VersionMadeBy">
            <summary>
            Get the version made by for this entry or zero if unknown.
            The value / 10 indicates the major version number, and 
            the value mod 10 is the minor version number
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsDOSEntry">
            <summary>
            Get a value indicating this entry is for a DOS/Windows system.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.HasDosAttributes(System.Int32)">
            <summary>
            Test the external attributes for this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"/> to
            see if the external attributes are Dos based (including WINNT and variants)
            and match the values
            </summary>
            <param name="attributes">The attributes to test.</param>
            <returns>Returns true if the external attributes are known to be DOS/Windows 
            based and have the same attributes set as the value passed.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.HostSystem">
            <summary>
            Gets the compatability information for the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">external file attribute</see>
            If the external file attributes are compatible with MS-DOS and can be read
            by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value
            will be non-zero and identify the host system on which the attributes are compatible.
            </summary>
            		
            <remarks>
            The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
            misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
            to obtain up to date and correct information.  The modified appnote by the infozip group is
            particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
            <list type="table">
            <item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item>
            <item>1 - Amiga</item>
            <item>2 - OpenVMS</item>
            <item>3 - Unix</item>
            <item>4 - VM/CMS</item>
            <item>5 - Atari ST</item>
            <item>6 - OS/2 HPFS</item>
            <item>7 - Macintosh</item>
            <item>8 - Z-System</item>
            <item>9 - CP/M</item>
            <item>10 - Windows NTFS</item>
            <item>11 - MVS (OS/390 - Z/OS)</item>
            <item>12 - VSE</item>
            <item>13 - Acorn Risc</item>
            <item>14 - VFAT</item>
            <item>15 - Alternate MVS</item>
            <item>16 - BeOS</item>
            <item>17 - Tandem</item>
            <item>18 - OS/400</item>
            <item>19 - OS/X (Darwin)</item>
            <item>99 - WinZip AES</item>
            <item>remainder - unused</item>
            </list>
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Version">
            <summary>
            Get minimum Zip feature version required to extract this entry
            </summary>		
            <remarks>
            Minimum features are defined as:<br/>
            1.0 - Default value<br/>
            1.1 - File is a volume label<br/>
            2.0 - File is a folder/directory<br/>
            2.0 - File is compressed using Deflate compression<br/>
            2.0 - File is encrypted using traditional encryption<br/>
            2.1 - File is compressed using Deflate64<br/>
            2.5 - File is compressed using PKWARE DCL Implode<br/>
            2.7 - File is a patch data set<br/>
            4.5 - File uses Zip64 format extensions<br/>
            4.6 - File is compressed using BZIP2 compression<br/>
            5.0 - File is encrypted using DES<br/>
            5.0 - File is encrypted using 3DES<br/>
            5.0 - File is encrypted using original RC2 encryption<br/>
            5.0 - File is encrypted using RC4 encryption<br/>
            5.1 - File is encrypted using AES encryption<br/>
            5.1 - File is encrypted using corrected RC2 encryption<br/>
            5.1 - File is encrypted using corrected RC2-64 encryption<br/>
            6.1 - File is encrypted using non-OAEP key wrapping<br/>
            6.2 - Central directory encryption (not confirmed yet)<br/>
            6.3 - File is compressed using LZMA<br/>
            6.3 - File is compressed using PPMD+<br/>
            6.3 - File is encrypted using Blowfish<br/>
            6.3 - File is encrypted using Twofish<br/>
            </remarks>
            <seealso cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CanDecompress">
            <summary>
            Get a value indicating whether this entry can be decompressed by the library.
            </summary>
            <remarks>This is based on the <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Version"></see> and 
            wether the <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">compression method</see> is supported.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ForceZip64">
            <summary>
            Force this entry to be recorded using Zip64 extensions.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsZip64Forced">
            <summary>
            Get a value indicating wether Zip64 extensions were forced.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value of true if Zip64 extensions have been forced on; false if not.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.LocalHeaderRequiresZip64">
            <summary>
            Gets a value indicating if the entry requires Zip64 extensions 
            to store the full entry values.
            </summary>
            <value>A <see cref="T:System.Boolean"/> value of true if a local header requires Zip64 extensions; false if not.</value>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CentralHeaderRequiresZip64">
            <summary>
            Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DosTime">
            <summary>
            Get/Set DosTime value.
            </summary>
            <remarks>
            The MS-DOS date format can only represent dates between 1/1/1980 and 12/31/2107.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DateTime">
            <summary>
            Gets/Sets the time of last modification of the entry.
            </summary>
            <remarks>
            The <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.DosTime"></see> property is updated to match this as far as possible.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Name">
             <summary>
             Returns the entry name.
             </summary>
             <remarks>
             The unix naming convention is followed.
             Path components in the entry should always separated by forward slashes ('/').
             Dos device names like C: should also be removed.
             See the ZipNameTransform class, or <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)"/>
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Size">
            <summary>
            Gets/Sets the size of the uncompressed data.
            </summary>
            <returns>
            The size or -1 if unknown.
            </returns>
            <remarks>Setting the size before adding an entry to an archive can help
            avoid compatability problems with some archivers which dont understand Zip64 extensions.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressedSize">
            <summary>
            Gets/Sets the size of the compressed data.
            </summary>
            <returns>
            The compressed entry size or -1 if unknown.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Crc">
            <summary>
            Gets/Sets the crc of the uncompressed data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Crc is not in the range 0..0xffffffffL
            </exception>
            <returns>
            The crc value or -1 if unknown.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethod">
            <summary>
            Gets/Sets the compression method. Only Deflated and Stored are supported.
            </summary>
            <returns>
            The compression method for this entry
            </returns>
            <see cref="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Deflated"/>
            <see cref="F:ICSharpCode.SharpZipLib.Zip.CompressionMethod.Stored"/>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethodForHeader">
            <summary>
            Gets the compression method for outputting to the local or central header.
            Returns same value as CompressionMethod except when AES encrypting, which
            places 99 in the method and places the real method in the extra data.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.ExtraData">
            <summary>
            Gets/Sets the extra data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Extra data is longer than 64KB (0xffff) bytes.
            </exception>
            <returns>
            Extra data or null if not set.
            </returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESKeySize">
            <summary>
            For AES encrypted files returns or sets the number of bits of encryption (128, 192 or 256).
            When setting, only 0 (off), 128 or 256 is supported.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESEncryptionStrength">
            <summary>
            AES Encryption strength for storage in extra data in entry header.
            1 is 128 bit, 2 is 192 bit, 3 is 256 bit.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESSaltLen">
            <summary>
            Returns the length of the salt, in bytes 
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.AESOverheadSize">
            <summary>
            Number of extra bytes required to hold the AES Header fields (Salt, Pwd verify, AuthCode)
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ProcessExtraData(System.Boolean)">
            <summary>
            Process extra data fields updating the entry based on the contents.
            </summary>
            <param name="localHeader">True if the extra data fields should be handled
            for a local header, rather than for a central header.
            </param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.Comment">
            <summary>
            Gets/Sets the entry comment.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If comment is longer than 0xffff.
            </exception>
            <returns>
            The comment or null if not set.
            </returns>
            <remarks>
            A comment is only available for entries when read via the ZipFile class.
            The ZipInputStream class doesnt have the comment data available.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsDirectory">
            <summary>
            Gets a value indicating if the entry is a directory.
            however.
            </summary>
            <remarks>
            A directory is determined by an entry name with a trailing slash '/'.
            The external file attributes can also indicate an entry is for a directory.
            Currently only dos/windows attributes are tested in this manner.
            The trailing slash convention should always be followed.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsFile">
            <summary>
            Get a value of true if the entry appears to be a file; false otherwise
            </summary>
            <remarks>
            This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
            For linux and others the result may be incorrect.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">
            <summary>
            Test entry to see if data can be extracted.
            </summary>
            <returns>Returns true if data can be extracted for this entry; false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.Clone">
            <summary>
            Creates a copy of this zip entry.
            </summary>
            <returns>An <see cref="T:System.Object"/> that is a copy of the current instance.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.ToString">
            <summary>
            Gets a string representation of this ZipEntry.
            </summary>
            <returns>A readable textual representation of this <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipEntry"/></returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported(ICSharpCode.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Test a <see cref="P:ICSharpCode.SharpZipLib.Zip.ZipEntry.CompressionMethod">compression method</see> to see if this library
            supports extracting data compressed with that method
            </summary>
            <param name="method">The compression method to test.</param>
            <returns>Returns true if the compression method is supported; false otherwise</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">
            <summary>
            Cleans a name making it conform to Zip file conventions.
            Devices names ('c:\') and UNC share names ('\\server\share') are removed
            and forward slashes ('\') are converted to back slashes ('/').
            Names are made relative by trimming leading slashes which is compatible
            with the ZIP naming convention.
            </summary>
            <param name="name">The name to clean</param>
            <returns>The 'cleaned' name.</returns>
            <remarks>
            The ZipNameTransform Zip name transform class is more flexible.
            </remarks>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipException">
            <summary>
            ZipException represents exceptions specific to Zip classes and code.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipException" />.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipException" /> with its message string.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of <see cref="T:ICSharpCode.SharpZipLib.Zip.ZipException" />.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
            <param name="innerException">The <see cref="T:System.Exception"/> that caused this exception.</param>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">
            <summary>
            ExtraData tagged value interface.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ITaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the contents of this instance from the data passed.
            </summary>
            <param name="data">The data to extract contents from.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedData.GetData">
            <summary>
            Get the data representing this instance.
            </summary>
            <returns>Returns the data for this instance.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.RawTaggedData">
            <summary>
            A raw binary tagged value
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.#ctor(System.Int16)">
            <summary>
            Initialise a new instance.
            </summary>
            <param name="tag">The tag ID.</param>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.RawTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="offset">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.RawTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.RawTaggedData.Data">
            <summary>
            Get /set the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.RawTaggedData._tag">
            <summary>
            The tag ID for this instance.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData">
            <summary>
            Class representing extended unix date time values.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags">
            <summary>
            Flags indicate which values are included in this instance.
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.ModificationTime">
            <summary>
            The modification time is included
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.AccessTime">
            <summary>
            The access time is included
            </summary>
        </member>
        <member name="F:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags.CreateTime">
            <summary>
            The create time is included.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.TagID">
            <summary>
            Get the ID
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> value to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>The standard Unix time is a signed integer data type, directly encoding the Unix time number,
            which is the number of seconds since 1970-01-01.
            Being 32 bits means the values here cover a range of about 136 years.
            The minimum representable time is 1901-12-13 20:45:52,
            and the maximum representable time is 2038-01-19 03:14:07.
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.ModificationTime">
            <summary>
            Get /set the Modification Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.AccessTime">
            <summary>
            Get / set the Access Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.CreateTime">
            <summary>
            Get / Set the Create Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Include">
            <summary>
            Get/set the <see cref="T:ICSharpCode.SharpZipLib.Zip.ExtendedUnixData.Flags">values</see> to include.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.NTTaggedData">
            <summary>
            Class handling NT date time values.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.NTTaggedData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> valuie to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>
            NTFS filetimes are 64-bit unsigned integers, stored in Intel
            (least significant byte first) byte order. They determine the
            number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
            which is "01-Jan-1601 00:00:00 UTC". 28 May 60056 is the upper limit
            </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.LastModificationTime">
            <summary>
            Get/set the <see cref="T:System.DateTime">last modification time</see>.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.CreateTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">create time</see>
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.NTTaggedData.LastAccessTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">last access time</see>.
            </summary>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ITaggedDataFactory">
            <summary>
            A factory that creates <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged data</see> instances.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ITaggedDataFactory.Create(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get data for a specific tag value.
            </summary>
            <param name="tag">The tag ID to find.</param>
            <param name="data">The data to search.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
            <returns>The located <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">value found</see>, or null if not found.</returns>
        </member>
        <member name="T:ICSharpCode.SharpZipLib.Zip.ZipExtraData">
            
            <summary>
            A class to handle the extra data field for Zip entries
            </summary>
            <remarks>
            Extra data contains 0 or more values each prefixed by a header tag and length.
            They contain zero or more bytes of actual data.
            The data is held internally using a copy on write strategy.  This is more efficient but
            means that for extra data created by passing in data can have the values modified by the caller
            in some circumstances.
            </remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.#ctor">
            <summary>
            Initialise a default instance.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.#ctor(System.Byte[])">
            <summary>
            Initialise with known extra data.
            </summary>
            <param name="data">The extra data.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetEntryData">
            <summary>
            Get the raw extra data value
            </summary>
            <returns>Returns the raw byte[] extra data this instance represents.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Clear">
            <summary>
            Clear the stored data.
            </summary>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Length">
            <summary>
            Gets the current extra data length.
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetStreamForTag(System.Int32)">
            <summary>
            Get a read-only <see cref="T:System.IO.Stream"/> for the associated tag.
            </summary>
            <param name="tag">The tag to locate data for.</param>
            <returns>Returns a <see cref="T:System.IO.Stream"/> containing tag data or null if no tag was found.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.GetData``1">
            <summary>
            Get the <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged data</see> for a tag.
            </summary>
            <typeparam name="T">The tag to search for.</typeparam>
            <returns>Returns a <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData">tagged value</see> or null if none found.</returns>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ValueLength">
            <summary>
            Get the length of the last value found by <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/>
            </summary>
            <remarks>This is only valid if <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/> has previously returned true.</remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.CurrentReadIndex">
            <summary>
            Get the index for the current read value.
            </summary>
            <remarks>This is only valid if <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/> has previously returned true.
            Initially the result will be the index of the first byte of actual data.  The value is updated after calls to
            <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadInt"/>, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort"/> and <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadLong"/>. </remarks>
        </member>
        <member name="P:ICSharpCode.SharpZipLib.Zip.ZipExtraData.UnreadCount">
            <summary>
            Get the number of bytes remaining to be read for the current value;
            </summary>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">
            <summary>
            Find an extra data value
            </summary>
            <param name="headerID">The identifier for the value to find.</param>
            <returns>Returns true if the value was found; false otherwise.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(ICSharpCode.SharpZipLib.Zip.ITaggedData)">
            <summary>
            Add a new entry to extra data.
            </summary>
            <param name="taggedData">The <see cref="T:ICSharpCode.SharpZipLib.Zip.ITaggedData"/> value to add.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(System.Int32,System.Byte[])">
            <summary>
            Add a new entry to extra data
            </summary>
            <param name="headerID">The ID for this entry.</param>
            <param name="fieldData">The data to add.</param>
            <remarks>If the ID already exists its contents are replaced.</remarks>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry">
            <summary>
            Start adding a new entry.
            </summary>
            <remarks>Add data using <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])"/>, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)"/>, <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)"/>, or <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)"/>.
            The new entry is completed and actually added by calling <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)"/></remarks>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddEntry(ICSharpCode.SharpZipLib.Zip.ITaggedData)"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)">
            <summary>
            Add entry data added since <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/> using the ID passed.
            </summary>
            <param name="headerID">The identifier to use for this entry.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte)">
            <summary>
            Add a byte of data to the pending new entry.
            </summary>
            <param name="data">The byte to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])">
            <summary>
            Add data to a pending new entry.
            </summary>
            <param name="data">The data to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)">
            <summary>
            Add a short value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)">
            <summary>
            Add an integer value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)">
            <summary>
            Add a long value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Delete(System.Int32)">
            <summary>
            Delete an extra data field.
            </summary>
            <param name="headerID">The identifier of the field to delete.</param>
            <returns>Returns true if the field was found and deleted.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadLong">
            <summary>
            Read a long in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value
            </summary>
            <returns>Returns the long value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadInt">
            <summary>
            Read an integer in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the integer read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort">
            <summary>
            Read a short value in little endian form from the last <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadByte">
            <summary>
            Read a byte from an extra data
            </summary>
            <returns>The byte value read or -1 if the end of data has been reached.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Skip(System.Int32)">
            <summary>
            Skip data during reading.
            </summary>
            <param name="amount">The number of bytes to skip.</param>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShortInternal">
            <summary>
            Internal form of <see cref="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.ReadShort"/> that reads data at any location.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:ICSharpCode.SharpZipLib.Zip.ZipExtraData.Dispose">
            <summary>
            Dispose of this instance.
            </summary>
        </member>
        <member name="T:CatLib.Compress.CompressProvider">
            <summary>
            压缩解压缩服务提供者
            </summary>
        </member>
        <member name="P:CatLib.Compress.CompressProvider.DefaultLevel">
            <summary>
            默认压缩等级
            </summary>
        </member>
        <member name="M:CatLib.Compress.CompressProvider.#ctor">
            <summary>
            压缩解压缩服务提供者
            </summary>
        </member>
        <member name="M:CatLib.Compress.CompressProvider.Init">
            <summary>
            服务提供者初始化
            </summary>
        </member>
        <member name="M:CatLib.Compress.CompressProvider.Register">
            <summary>
            当注册服务提供者
            </summary>
        </member>
        <member name="T:CatLib.Compress.GZipAdapter">
            <summary>
            Gzip压缩解压缩
            </summary>
        </member>
        <member name="F:CatLib.Compress.GZipAdapter.level">
            <summary>
            压缩等级
            </summary>
        </member>
        <member name="M:CatLib.Compress.GZipAdapter.#ctor(System.Int32)">
            <summary>
            压缩解压缩
            </summary>
            <param name="level">压缩等级</param>
        </member>
        <member name="M:CatLib.Compress.GZipAdapter.Compress(System.Byte[])">
            <summary>
            压缩
            </summary>
            <param name="bytes">需要压缩的字节流</param>
            <returns>压缩后的结果</returns>
        </member>
        <member name="M:CatLib.Compress.GZipAdapter.Decompress(System.Byte[])">
            <summary>
            解压缩
            </summary>
            <param name="bytes">需要解压缩的字节流</param>
            <returns>解压缩的结果</returns>
        </member>
        <member name="T:CatLib.Compress.CompressManager">
            <summary>
            压缩解压缩
            </summary>
        </member>
        <member name="M:CatLib.Compress.CompressManager.Compress(System.Byte[],System.String)">
            <summary>
            压缩
            </summary>
            <param name="bytes">需要压缩的字节流</param>
            <param name="name">使用的压缩解压缩名字</param>
            <returns>压缩后的结果</returns>
        </member>
        <member name="M:CatLib.Compress.CompressManager.Decomporess(System.Byte[],System.String)">
            <summary>
            解压缩
            </summary>
            <param name="bytes">需要解压缩的字节流</param>
            <param name="name">使用的压缩解压缩名字</param>
            <returns>解压缩的结果</returns>
        </member>
        <member name="T:CatLib.Compress.LzmaAdapter">
            <summary>
            Lzma压缩解压缩
            </summary>
        </member>
        <member name="M:CatLib.Compress.LzmaAdapter.Compress(System.Byte[])">
            <summary>
            压缩
            </summary>
            <param name="bytes">需要压缩的字节流</param>
            <returns>压缩后的结果</returns>
        </member>
        <member name="M:CatLib.Compress.LzmaAdapter.Decompress(System.Byte[])">
            <summary>
            解压缩
            </summary>
            <param name="bytes">需要解压缩的字节流</param>
            <returns>解压缩的结果</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.IListStringStringConverter">
            <summary>
            IList string转string
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.IListStringStringConverter.From">
            <summary>
            来源类型
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.IListStringStringConverter.To">
            <summary>
            目标类型
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.IListStringStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringIListStringConverter">
            <summary>
            string转IList string
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringIListStringConverter.From">
            <summary>
            来源类型
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringIListStringConverter.To">
            <summary>
            目标类型
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringIListStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.BoolStringConverter">
            <summary>
            bool转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.BoolStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.BoolStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.BoolStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.ByteStringConverter">
            <summary>
            byte转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.ByteStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.ByteStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.ByteStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.CharStringConverter">
            <summary>
            char转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.CharStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.CharStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.CharStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.DateTimeStringConverter">
            <summary>
            datetime转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.DateTimeStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.DateTimeStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.DateTimeStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.DecimalStringConverter">
            <summary>
            decimal转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.DecimalStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.DecimalStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.DecimalStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.DoubleStringConverter">
            <summary>
            double转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.DoubleStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.DoubleStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.DoubleStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.EnumStringConverter">
            <summary>
            enum转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.EnumStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.EnumStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.EnumStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.Int16StringConverter">
            <summary>
            int16转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.Int16StringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.Int16StringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.Int16StringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.Int32StringConverter">
            <summary>
            int32转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.Int32StringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.Int32StringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.Int32StringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.Int64StringConverter">
            <summary>
            int64转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.Int64StringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.Int64StringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.Int64StringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.SByteStringConverter">
            <summary>
            sbyte转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.SByteStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.SByteStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.SByteStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.SingleStringConverter">
            <summary>
            single转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.SingleStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.SingleStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.SingleStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringBoolConverter">
            <summary>
            string转bool转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringBoolConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringBoolConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringBoolConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringByteConverter">
            <summary>
            string转byte转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringByteConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringByteConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringByteConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringCharConverter">
            <summary>
            string转char转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringCharConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringCharConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringCharConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringDateTimeConverter">
            <summary>
            string转datetime转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringDateTimeConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringDateTimeConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringDateTimeConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringDecimalConverter">
            <summary>
            string转decimal转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringDecimalConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringDecimalConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringDecimalConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringDoubleConverter">
            <summary>
            string转double转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringDoubleConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringDoubleConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringDoubleConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringEnumConverter">
            <summary>
            string转enum转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringEnumConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringEnumConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringEnumConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringInt16Converter">
            <summary>
            string转int16转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringInt16Converter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringInt16Converter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringInt16Converter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringInt32Converter">
            <summary>
            string转int32转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringInt32Converter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringInt32Converter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringInt32Converter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringInt64Converter">
            <summary>
            string转long转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringInt64Converter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringInt64Converter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringInt64Converter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringSByteConverter">
            <summary>
            string转int32转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringSByteConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringSByteConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringSByteConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringSingleConverter">
            <summary>
            string转float转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringSingleConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringSingleConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringSingleConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringStringConverter">
            <summary>
            string转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringStringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringStringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringStringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringUInt16Converter">
            <summary>
            string转uint16转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringUInt16Converter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringUInt16Converter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringUInt16Converter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringUInt32Converter">
            <summary>
            string转int转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringUInt32Converter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringUInt32Converter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringUInt32Converter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.StringUInt64Converter">
            <summary>
            string转ulong转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringUInt64Converter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.StringUInt64Converter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.StringUInt64Converter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.UInt16StringConverter">
            <summary>
            uint16转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.UInt16StringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.UInt16StringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.UInt16StringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.UInt32StringConverter">
            <summary>
            uint转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.UInt32StringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.UInt32StringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.UInt32StringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Plan.UInt64StringConverter">
            <summary>
            ulong转string转换器
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.UInt64StringConverter.From">
            <summary>
            来源
            </summary>
        </member>
        <member name="P:CatLib.Converters.Plan.UInt64StringConverter.To">
            <summary>
            目标
            </summary>
        </member>
        <member name="M:CatLib.Converters.Plan.UInt64StringConverter.ConvertTo(System.Object,System.Type)">
            <summary>
            源类型转换到目标类型
            </summary>
            <param name="source">源类型</param>
            <param name="to">目标类型</param>
            <returns>目标类型</returns>
        </member>
        <member name="T:CatLib.Converters.Converters">
            <summary>
            转换器
            </summary>
        </member>
        <member name="F:CatLib.Converters.Converters.coverterDictionary">
            <summary>
            转换器字典
            </summary>
        </member>
        <member name="M:CatLib.Converters.Converters.#ctor">
            <summary>
            构建一个转换器
            </summary>
        </member>
        <member name="M:CatLib.Converters.Converters.AddConverter(CatLib.API.Converters.ITypeConverter)">
            <summary>
            增加一个转换器
            </summary>
            <param name="converter">转换器</param>
        </member>
        <member name="M:CatLib.Converters.Converters.Convert(System.Object,System.Type)">
            <summary>
            从源类型转为目标类型
            </summary>
            <param name="source">源数据</param>
            <param name="to">目标类型</param>
            <returns>目标数据</returns>
        </member>
        <member name="M:CatLib.Converters.Converters.Convert``1(System.Object)">
            <summary>
            从源类型转为目标类型
            </summary>
            <typeparam name="TTarget">目标类型</typeparam>
            <param name="source">源数据</param>
            <returns>目标数据</returns>
        </member>
        <member name="M:CatLib.Converters.Converters.TryConvert(System.Object,System.Object@,System.Type)">
            <summary>
            从源类型转为目标类型
            </summary>
            <param name="source">源数据</param>
            <param name="target">目标数据</param>
            <param name="to">目标类型</param>
            <returns>是否成功转换</returns>
        </member>
        <member name="M:CatLib.Converters.Converters.TryConvert``1(System.Object,``0@)">
            <summary>
            从源类型转为目标类型
            </summary>
            <typeparam name="TTarget">目标类型</typeparam>
            <param name="source">源数据</param>
            <param name="target">目标数据</param>
            <returns>是否成功转换</returns>
        </member>
        <member name="M:CatLib.Converters.Converters.TryGetConverter(System.Type,System.Type,CatLib.API.Converters.ITypeConverter@)">
            <summary>
            获取类型所需的转换器
            </summary>
            <param name="from">来源类型</param>
            <param name="to">目标类型</param>
            <param name="converter">转换器</param>
            <returns>是否成功获取转换器</returns>
        </member>
        <member name="M:CatLib.Converters.Converters.FindConverterByType``1(System.Collections.Generic.IDictionary{System.Type,``0},System.Type,``0@)">
            <summary>
            根据类型查找转换器
            </summary>
            <typeparam name="TValue">字典值类型</typeparam>
            <param name="dict">查询字典</param>
            <param name="baseType">基础类型</param>
            <param name="value">查找到的值</param>
            <returns>是否成功找到</returns>
        </member>
        <member name="T:CatLib.Converters.ConvertersManager">
            <summary>
            转换器管理器
            </summary>
        </member>
        <member name="M:CatLib.Converters.ConvertersManager.CloneExtend(System.String,System.String)">
            <summary>
            克隆指定转换器(注意克隆只克隆解决器提供的结果)
            </summary>
            <param name="newExtendName">新的名字</param>
            <param name="cloneFromExtendName">克隆自的管理器名字</param>
            <returns>转换器</returns>
        </member>
        <member name="T:CatLib.Converters.ConvertersProvider">
            <summary>
            转换器服务
            </summary>
        </member>
        <member name="M:CatLib.Converters.ConvertersProvider.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:CatLib.Converters.ConvertersProvider.Register">
            <summary>
            注册文件系统服务
            </summary>
        </member>
        <member name="M:CatLib.Converters.ConvertersProvider.RegisterManager">
            <summary>
            注册管理器
            </summary>
        </member>
        <member name="M:CatLib.Converters.ConvertersProvider.RegisterDefaultConverter">
            <summary>
            注册默认的转换器
            </summary>
        </member>
        <member name="M:CatLib.Converters.ConvertersProvider.LoadDefaultConverters">
            <summary>
            加载默认的转换器
            </summary>
            <returns>默认的转换器</returns>
        </member>
        <member name="T:CatLib.Debugger.Log.LogUtil">
            <summary>
            Log通用工具
            </summary>
        </member>
        <member name="F:CatLib.Debugger.Log.LogUtil.lastId">
            <summary>
            日志LastId
            </summary>
        </member>
        <member name="M:CatLib.Debugger.Log.LogUtil.GetLastId">
            <summary>
            获取日志LastId
            </summary>
            <returns>日志LastId</returns>
        </member>
        <member name="T:CatLib.Debugger.Log.ILogEntry">
            <summary>
            日志条目
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.ILogEntry.Id">
            <summary>
            条目id
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.ILogEntry.Level">
            <summary>
            日志等级
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.ILogEntry.Message">
            <summary>
            日志内容
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.ILogEntry.Namespace">
            <summary>
            命名空间
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.ILogEntry.Time">
            <summary>
            记录时间
            </summary>
        </member>
        <member name="M:CatLib.Debugger.Log.ILogEntry.GetStackTrace(System.Predicate{System.String})">
            <summary>
            获取调用堆栈
            </summary>
            <param name="assemblyMatch">程序集是否符合输出条件</param>
            <returns>调用堆栈</returns>
        </member>
        <member name="M:CatLib.Debugger.Log.ILogEntry.IsIgnore(System.Type)">
            <summary>
            是否可以被忽略
            </summary>
            <param name="type">处理器类型</param>
            <returns>是否可以忽略这个处理器</returns>
        </member>
        <member name="T:CatLib.Debugger.Log.Logger">
            <summary>
            日志系统
            </summary>
        </member>
        <member name="F:CatLib.Debugger.Log.Logger.handlers">
            <summary>
            日志处理器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.Log.Logger.syncRoot">
            <summary>
            同步锁
            </summary>
        </member>
        <member name="F:CatLib.Debugger.Log.Logger.skipFrames">
            <summary>
            调用堆栈忽略的步数
            </summary>
        </member>
        <member name="F:CatLib.Debugger.Log.Logger.callCount">
            <summary>
            调用计数
            </summary>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.#ctor">
            <summary>
            构造一个日志系统
            </summary>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.SetSkip(System.Int32,System.Action)">
            <summary>
            设定调用堆栈忽略的步数
            </summary>
            <param name="skipFrames">跳过的步数</param>
            <param name="area">作用区域</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.AddLogHandler(CatLib.Debugger.Log.ILogHandler)">
            <summary>
            增加日志处理器
            </summary>
            <param name="handler">处理器</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Log(CatLib.API.Debugger.LogLevels,System.Object,System.Object[])">
            <summary>
            输出一条日志，日志级别为传入的等级
            </summary>
            <param name="level">日志等级</param>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
            <exception cref="T:CatLib.API.Debugger.InvalidArgumentException">当传入的日志等级无效</exception>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Log(CatLib.Debugger.Log.ILogEntry)">
            <summary>
            输出日志内容
            </summary>
            <param name="entry">日志实体</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.ExecLog(CatLib.API.Debugger.LogLevels,System.Object,System.Object[])">
            <summary>
            将日志推入日志处理器
            </summary>
            <param name="level">日志等级</param>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
            <exception cref="T:CatLib.API.Debugger.InvalidArgumentException">当传入的日志等级无效</exception>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Debug(System.Object,System.Object[])">
            <summary>
            输出一条调试级日志
            </summary>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Info(System.Object,System.Object[])">
            <summary>
            输出一条信息级日志
            </summary>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Notice(System.Object,System.Object[])">
            <summary>
            输出一条通知级日志
            </summary>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Warning(System.Object,System.Object[])">
            <summary>
            输出一条警告级日志
            </summary>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Error(System.Object,System.Object[])">
            <summary>
            输出一条错误级日志
            </summary>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Critical(System.Object,System.Object[])">
            <summary>
            输出一条关键级日志
            </summary>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Alert(System.Object,System.Object[])">
            <summary>
            输出一条警报级日志
            </summary>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.Emergency(System.Object,System.Object[])">
            <summary>
            输出一条紧急级日志
            </summary>
            <param name="message">日志内容</param>
            <param name="context">上下文,用于替换占位符</param>
        </member>
        <member name="M:CatLib.Debugger.Log.Logger.MakeLogEntry(CatLib.API.Debugger.LogLevels,System.String)">
            <summary>
            制作一个日志条目
            </summary>
            <param name="level">日志等级</param>
            <param name="message">日志</param>
            <returns>日志条目</returns>
        </member>
        <member name="T:CatLib.Debugger.Log.ILogHandler">
            <summary>
            日志处理器
            </summary>
        </member>
        <member name="M:CatLib.Debugger.Log.ILogHandler.Handler(CatLib.Debugger.Log.ILogEntry)">
            <summary>
            日志处理器
            </summary>
            <param name="log">日志条目</param>
        </member>
        <member name="T:CatLib.Debugger.Log.Handler.StdOutLogHandler">
            <summary>
            标准输出日志处理器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.Log.Handler.StdOutLogHandler.mapping">
            <summary>
            实际处理方法
            </summary>
        </member>
        <member name="M:CatLib.Debugger.Log.Handler.StdOutLogHandler.#ctor">
            <summary>
            标准输出日志处理器
            </summary>
        </member>
        <member name="M:CatLib.Debugger.Log.Handler.StdOutLogHandler.Handler(CatLib.Debugger.Log.ILogEntry)">
            <summary>
            日志处理器
            </summary>
            <param name="log">日志条目</param>
        </member>
        <member name="T:CatLib.Debugger.Log.LogEntry">
            <summary>
            日志条目记录
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.LogEntry.Id">
            <summary>
            条目id
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.LogEntry.Level">
            <summary>
            日志等级
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.LogEntry.StackTrace">
            <summary>
            调用堆栈
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.LogEntry.Message">
            <summary>
            日志内容
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.LogEntry.Namespace">
            <summary>
            命名空间
            </summary>
        </member>
        <member name="P:CatLib.Debugger.Log.LogEntry.Time">
            <summary>
            记录时间
            </summary>
        </member>
        <member name="M:CatLib.Debugger.Log.LogEntry.#ctor(CatLib.API.Debugger.LogLevels,System.String,System.Int32)">
            <summary>
            日志条目记录
            </summary>
            <param name="level">日志等级</param>
            <param name="message">消息内容</param>
            <param name="skipFrams">跳过的帧数</param>
        </member>
        <member name="M:CatLib.Debugger.Log.LogEntry.GetStackTrace(System.Predicate{System.String})">
            <summary>
            获取调用堆栈
            </summary>
            <param name="assemblyMatch">程序集是否符合输出条件</param>
            <returns>调用堆栈</returns>
        </member>
        <member name="M:CatLib.Debugger.Log.LogEntry.IsIgnore(System.Type)">
            <summary>
            是否可以被忽略
            </summary>
            <param name="type">处理器类型</param>
            <returns>是否可以忽略这个处理器</returns>
        </member>
        <member name="T:CatLib.Debugger.WebConsole.Protocol.GetGuid">
            <summary>
            GetGuid API
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebConsole.Protocol.GetGuid.Response">
            <summary>
            响应
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.Protocol.GetGuid.#ctor(System.Object)">
            <summary>
            GetGuid API
            </summary>
            <param name="response">响应</param>
        </member>
        <member name="T:CatLib.Debugger.WebConsole.BaseProtocol">
            <summary>
            基础协议
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebConsole.BaseProtocol.Response">
            <summary>
            数据
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.BaseProtocol.#ctor(System.Object)">
            <summary>
            基础协议
            </summary>
            <param name="response">响应</param>
        </member>
        <member name="T:CatLib.Debugger.WebConsole.HttpDebuggerConsole">
            <summary>
            http调试控制台
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebConsole.HttpDebuggerConsole.listener">
            <summary>
            http监听器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebConsole.HttpDebuggerConsole.router">
            <summary>
            路由器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebConsole.HttpDebuggerConsole.json">
            <summary>
            json处理器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebConsole.HttpDebuggerConsole.logger">
            <summary>
            日志记录器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebConsole.HttpDebuggerConsole.guid">
            <summary>
            当前唯一标识符
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebConsole.HttpDebuggerConsole.syncRoot">
            <summary>
            同步锁
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.#ctor(CatLib.API.Debugger.ILogger,CatLib.API.Routing.IRouter,CatLib.API.Json.IJson)">
            <summary>
            http调试控制台
            </summary>
            <param name="logger">日志记录器</param>
            <param name="router">路由器</param>
            <param name="json">json解析器</param>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.Finalize">
            <summary>
            当析构时
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.GetGuid(CatLib.API.Routing.IResponse)">
            <summary>
            获取控制台Guid
            </summary>
            <param name="response">响应</param>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.Start(System.String,System.Int32)">
            <summary>
            开启控制台服务
            </summary>
            <param name="host">监听host</param>
            <param name="port">监听端口</param>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.Stop">
            <summary>
            停止控制台服务
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.OnRequest(System.Net.HttpListenerContext)">
            <summary>
            当收到来自控制端的请求时
            </summary>
            <param name="context">请求上下文</param>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.DispatchToRouted(System.Net.HttpListenerContext)">
            <summary>
            调度到目标路由
            </summary>
            <param name="context">请求上下文</param>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.RoutedResponseHandler(System.Net.HttpListenerContext,CatLib.API.Routing.IResponse)">
            <summary>
            路由响应处理器
            </summary>
            <param name="context">请求上下文</param>
            <param name="response">路由响应</param>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpDebuggerConsole.RegisterNotFoundRouted">
            <summary>
            注册路由不存在
            </summary>
        </member>
        <member name="T:CatLib.Debugger.WebConsole.HttpListener">
            <summary>
            Http监听器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebConsole.HttpListener.listener">
            <summary>
            监听器
            </summary>
        </member>
        <member name="E:CatLib.Debugger.WebConsole.HttpListener.OnRequest">
            <summary>
            当请求时
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpListener.#ctor(System.String,System.Int32)">
            <summary>
            Http监听器
            </summary>
            <param name="host">监听host</param>
            <param name="port">监听端口</param>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpListener.Dispose">
            <summary>
            释放
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebConsole.HttpListener.ListenedRequest(System.IAsyncResult)">
            <summary>
            监听到请求时
            </summary>
        </member>
        <member name="T:CatLib.Debugger.WebConsole.IWebConsoleResponse">
            <summary>
            Web控制台响应
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebConsole.IWebConsoleResponse.Response">
            <summary>
            响应
            </summary>
        </member>
        <member name="T:CatLib.Debugger.IMonitor">
            <summary>
            监控
            </summary>
        </member>
        <member name="M:CatLib.Debugger.IMonitor.Monitor(CatLib.Debugger.IMonitorHandler)">
            <summary>
            增加监控
            </summary>
            <param name="handler">监控句柄</param>
        </member>
        <member name="T:CatLib.Debugger.IMonitorHandler">
            <summary>
            监控句柄
            </summary>
        </member>
        <member name="P:CatLib.Debugger.IMonitorHandler.Name">
            <summary>
            监控的名字
            </summary>
        </member>
        <member name="P:CatLib.Debugger.IMonitorHandler.Tags">
            <summary>
            标签(第0位：分类)
            </summary>
        </member>
        <member name="P:CatLib.Debugger.IMonitorHandler.Unit">
            <summary>
            监控值的单位
            </summary>
        </member>
        <member name="P:CatLib.Debugger.IMonitorHandler.Value">
            <summary>
            监控值
            </summary>
        </member>
        <member name="T:CatLib.Debugger.DebuggerProvider">
            <summary>
            调试服务
            </summary>
        </member>
        <member name="P:CatLib.Debugger.DebuggerProvider.LogHandlers">
            <summary>
            启用的日志句柄
            </summary>
        </member>
        <member name="P:CatLib.Debugger.DebuggerProvider.AutoMake">
            <summary>
            自动生成列表
            </summary>
        </member>
        <member name="P:CatLib.Debugger.DebuggerProvider.IndexMonitor">
            <summary>
            首页的日志显示
            </summary>
        </member>
        <member name="P:CatLib.Debugger.DebuggerProvider.StdConsoleLoggerHandler">
            <summary>
            控制台日志处理器
            </summary>
        </member>
        <member name="P:CatLib.Debugger.DebuggerProvider.WebConsoleEnable">
            <summary>
            WebConsole是否启用
            </summary>
        </member>
        <member name="P:CatLib.Debugger.DebuggerProvider.WebConsoleHost">
            <summary>
            Web控制器Host
            </summary>
        </member>
        <member name="P:CatLib.Debugger.DebuggerProvider.WebConsolePort">
            <summary>
            Web控制台端口
            </summary>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.#ctor">
            <summary>
            构建一个调试服务提供者
            </summary>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.InitWebConsole">
            <summary>
            初始化Web控制台
            </summary>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.Register">
            <summary>
            注册调试服务
            </summary>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.GetLogHandlers">
            <summary>
            获取日志句柄
            </summary>
            <returns>句柄</returns>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.RegisterLogger">
            <summary>
            注册日志系统
            </summary>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.RegisterWebConsole">
            <summary>
            注册web控制台基础服务
            </summary>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.RegisterWebMonitor">
            <summary>
            注册监控
            </summary>
        </member>
        <member name="M:CatLib.Debugger.DebuggerProvider.RegisterWebLog">
            <summary>
            注册Web调试服务
            </summary>
        </member>
        <member name="T:CatLib.Debugger.WebMonitor.Handler.SizeMonitorHandler">
            <summary>
            基于尺寸大小的监控处理器(字节)
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Handler.SizeMonitorHandler.Tags">
            <summary>
            标签
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Handler.SizeMonitorHandler.Name">
            <summary>
            监控的名字
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Handler.SizeMonitorHandler.Unit">
            <summary>
            监控值的单位描述
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebMonitor.Handler.SizeMonitorHandler.unitMapping">
            <summary>
            单位映射
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebMonitor.Handler.SizeMonitorHandler.callback">
            <summary>
            回调获取结果
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Handler.SizeMonitorHandler.Value">
            <summary>
            实时的监控值
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.Handler.SizeMonitorHandler.#ctor(System.String,System.String[],System.Func{System.Object})">
            <summary>
            尺寸监控处理器
            </summary>
            <param name="name">监控名字</param>
            <param name="tags">标签</param>
            <param name="callback">回调获取结果</param>
        </member>
        <member name="T:CatLib.Debugger.WebMonitor.Handler.OnceRecordMonitorHandler">
            <summary>
            监控处理器
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Handler.OnceRecordMonitorHandler.Tags">
            <summary>
            标签
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Handler.OnceRecordMonitorHandler.Name">
            <summary>
            监控的名字
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Handler.OnceRecordMonitorHandler.Unit">
            <summary>
            监控值的单位描述
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Handler.OnceRecordMonitorHandler.Value">
            <summary>
            实时的监控值
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebMonitor.Handler.OnceRecordMonitorHandler.callback">
            <summary>
            回调获取结果
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.Handler.OnceRecordMonitorHandler.#ctor(System.String,System.String,System.String[],System.Func{System.Object})">
            <summary>
            单次记录监控处理器
            </summary>
            <param name="name">标题</param>
            <param name="unit">单位值</param>
            <param name="tags">tags</param>
            <param name="callback">回调</param>
        </member>
        <member name="T:CatLib.Debugger.WebMonitor.Controller.Monitor">
            <summary>
            监控
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.Controller.Monitor.GetMonitorsIndex(CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Collections.Generic.IEnumerable{System.String},CatLib.Debugger.WebMonitor.MonitorStore)">
            <summary>
            获取首页的监控
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="indexShow">首先显示的列表</param>
            <param name="monitorStore">容器存储</param>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.Controller.Monitor.GetMonitors(CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,CatLib.Debugger.WebMonitor.MonitorStore)">
            <summary>
            获取监控的详细数据
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="monitorStore">监控存储</param>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.Controller.Monitor.CallMainThread(CatLib.API.Routing.IRequest,System.Action)">
            <summary>
            主线程调用
            </summary>
            <param name="request">请求</param>
            <param name="action">调用方法</param>
        </member>
        <member name="T:CatLib.Debugger.WebMonitor.MonitorStore">
            <summary>
            监控器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebMonitor.MonitorStore.monitors">
            <summary>
            监控处理器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebMonitor.MonitorStore.monitorsDict">
            <summary>
            监控处理器字典
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.MonitorStore.#ctor">
            <summary>
            监控器
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.MonitorStore.System#Collections#Generic#IEnumerable{CatLib#Debugger#IMonitorHandler}#GetEnumerator">
            <summary>
            迭代器
            </summary>
            <returns>迭代器</returns>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.MonitorStore.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            迭代器
            </summary>
            <returns></returns>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.MonitorStore.Monitor(CatLib.Debugger.IMonitorHandler)">
            <summary>
            增加监控
            </summary>
            <param name="handler">监控句柄</param>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.MonitorStore.FindMoitor(System.String)">
            <summary>
            搜索监控处理器
            </summary>
            <param name="monitorName">监控名</param>
        </member>
        <member name="T:CatLib.Debugger.WebMonitor.Protocol.GetMonitors">
            <summary>
            获取监控信息
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebMonitor.Protocol.GetMonitors.Response">
            <summary>
            响应
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebMonitor.Protocol.GetMonitors.outputs">
            <summary>
            输出
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.Protocol.GetMonitors.#ctor">
            <summary>
            获取分组API
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.Protocol.GetMonitors.WriteLine(CatLib.Debugger.IMonitorHandler)">
            <summary>
            写入一条监控信息
            </summary>
            <param name="handler">处理器</param>
        </member>
        <member name="M:CatLib.Debugger.WebMonitor.Protocol.GetMonitors.WriteNotSupportLine(CatLib.Debugger.IMonitorHandler)">
            <summary>
            写入未支持行
            </summary>
            <param name="handler">处理器</param>
        </member>
        <member name="T:CatLib.Debugger.WebLog.Protocol.WebConsoleOutputs">
            <summary>
            Web控制台输出
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebLog.Protocol.WebConsoleOutputs.credibleAssemblys">
            <summary>
            可信任程序集
            </summary>
        </member>
        <member name="P:CatLib.Debugger.WebLog.Protocol.WebConsoleOutputs.Response">
            <summary>
            响应
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebLog.Protocol.WebConsoleOutputs.outputs">
            <summary>
            输出
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebLog.Protocol.WebConsoleOutputs.#ctor">
            <summary>
            Web控制台输出
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebLog.Protocol.WebConsoleOutputs.WriteLine(System.Int64,CatLib.API.Debugger.LogLevels,System.String,System.String,System.Collections.Generic.IList{System.String},System.Int64)">
            <summary>
            向Web控制台屏幕中输出一条消息
            </summary>
            <param name="id">消息id</param>
            <param name="level">消息等级</param>
            <param name="namespace">命名空间</param>
            <param name="message">消息标题</param>
            <param name="callStack">调用堆栈</param>
            <param name="time">记录时间</param>
        </member>
        <member name="M:CatLib.Debugger.WebLog.Protocol.WebConsoleOutputs.WriteLine(CatLib.Debugger.Log.ILogEntry)">
            <summary>
            向web控制台屏幕中输出一条消息
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:CatLib.Debugger.WebLog.Protocol.WebConsoleOutputs.IsCredibleAssembly(System.String)">
            <summary>
            是否是可信的程序集
            </summary>
            <param name="assembly">程序集</param>
            <returns>是否可信</returns>
        </member>
        <member name="T:CatLib.Debugger.WebLog.Controller.Log">
            <summary>
            日志
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebLog.Controller.Log.GetLog(CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,CatLib.Debugger.WebLog.LogStore)">
            <summary>
            获取日志
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="logStore">日志存储</param>
        </member>
        <member name="T:CatLib.Debugger.WebLog.Controller.Util">
            <summary>
            通用
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebLog.Controller.Util.Echo(CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,CatLib.API.Debugger.ILogger)">
            <summary>
            回显
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="logger">日志系统</param>
        </member>
        <member name="T:CatLib.Debugger.WebLog.LogStore">
            <summary>
            Web调试服务
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebLog.LogStore.clientIds">
            <summary>
            对应不同web客户端的已经读取到的最后的日志id
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebLog.LogStore.logEntrys">
            <summary>
            日志记录
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebLog.LogStore.maxLogEntrys">
            <summary>
            最大储存的日志记录数
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebLog.LogStore.#ctor(CatLib.Debugger.Log.Logger)">
            <summary>
            构造一个Web调试服务
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebLog.LogStore.SetMaxStore(System.Int32)">
            <summary>
            设定最大存储
            </summary>
            <param name="num"></param>
        </member>
        <member name="M:CatLib.Debugger.WebLog.LogStore.Log(CatLib.Debugger.Log.ILogEntry)">
            <summary>
            记录一个日志
            </summary>
            <param name="entry">日志条目</param>
        </member>
        <member name="M:CatLib.Debugger.WebLog.LogStore.GetUnloadEntrysByClientId(System.String)">
            <summary>
            根据客户端id获取未被加载过的日志数据
            </summary>
            <param name="clientId">客户端id</param>
            <returns>未被加载过的日志数据</returns>
        </member>
        <member name="T:CatLib.Debugger.WebLog.LogHandler.WebLogHandler">
            <summary>
            Web日志处理器
            </summary>
        </member>
        <member name="F:CatLib.Debugger.WebLog.LogHandler.WebLogHandler.store">
            <summary>
            日志存储
            </summary>
        </member>
        <member name="M:CatLib.Debugger.WebLog.LogHandler.WebLogHandler.#ctor(CatLib.Debugger.WebLog.LogStore)">
            <summary>
            网络日志处理器
            </summary>
            <param name="store"></param>
        </member>
        <member name="M:CatLib.Debugger.WebLog.LogHandler.WebLogHandler.Handler(CatLib.Debugger.Log.ILogEntry)">
            <summary>
            日志处理器
            </summary>
            <param name="log">日志条目</param>
        </member>
        <member name="T:CatLib.Encryption.AesEncrypter">
            <summary>
            Aes加解密
            </summary>
        </member>
        <member name="F:CatLib.Encryption.AesEncrypter.rijndaelManaged">
            <summary>
            RijndaelManaged
            </summary>
        </member>
        <member name="M:CatLib.Encryption.AesEncrypter.#ctor(System.Security.Cryptography.RijndaelManaged)">
            <summary>
            Aes加解密
            </summary>
            <param name="rijndaelManaged">RijndaelManaged</param>
        </member>
        <member name="M:CatLib.Encryption.AesEncrypter.#ctor(System.Int32,System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode)">
            <summary>
            Aes加解密
            </summary>
            <param name="size">密钥长度</param>
            <param name="mode">密码模式</param>
            <param name="padding">填充模式</param>
        </member>
        <member name="M:CatLib.Encryption.AesEncrypter.Encrypt(System.Byte[],System.Byte[])">
            <summary>
            加密
            </summary>
            <param name="content">加密内容</param>
            <param name="key">密钥</param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Encryption.AesEncrypter.Decrypt(System.String,System.Byte[])">
            <summary>
            解密被加密的内容
            </summary>
            <param name="str">需要解密的字符串</param>
            <param name="key">密钥</param>
            <returns>解密后的值</returns>
        </member>
        <member name="M:CatLib.Encryption.AesEncrypter.HMac(System.Byte[],System.Byte[])">
            <summary>
            计算HMac
            </summary>
            <param name="content">需要计算HMac的数据</param>
            <param name="key">密钥</param>
            <returns>HMac值</returns>
        </member>
        <member name="M:CatLib.Encryption.AesEncrypter.Encode(System.String,System.String,System.String)">
            <summary>
            加码
            </summary>
            <param name="iv">iv</param>
            <param name="value">加密值</param>
            <param name="hmac">验证码</param>
        </member>
        <member name="M:CatLib.Encryption.AesEncrypter.Decode(System.String,System.String@,System.String@,System.String@)">
            <summary>
            解码
            </summary>
            <param name="str">传入数据</param>
            <param name="iv">iv</param>
            <param name="value">加密至</param>
            <param name="hmac"></param>
        </member>
        <member name="T:CatLib.Encryption.Encrypter">
            <summary>
            加解密
            </summary>
        </member>
        <member name="F:CatLib.Encryption.Encrypter.encrypter">
            <summary>
            加解密实现
            </summary>
        </member>
        <member name="F:CatLib.Encryption.Encrypter.key">
            <summary>
            密钥
            </summary>
        </member>
        <member name="M:CatLib.Encryption.Encrypter.#ctor(System.Byte[],System.String)">
            <summary>
            加解密
            </summary>
            <param name="key">密钥</param>
            <param name="cipher">加密类型</param>
        </member>
        <member name="M:CatLib.Encryption.Encrypter.Encrypt(System.Byte[])">
            <summary>
            加密
            </summary>
            <param name="content">加密数据</param>
            <returns>加密后的数据</returns>
        </member>
        <member name="M:CatLib.Encryption.Encrypter.Decrypt(System.String)">
            <summary>
            解密
            </summary>
            <param name="payload">被加密的内容</param>
            <returns>解密内容</returns>
        </member>
        <member name="M:CatLib.Encryption.Encrypter.GetKey">
            <summary>
            获取密钥
            </summary>
            <returns></returns>
        </member>
        <member name="M:CatLib.Encryption.Encrypter.Supported(System.Byte[],System.String)">
            <summary>
            是否支持
            </summary>
            <param name="key">密钥</param>
            <param name="cipher">加密类型</param>
            <returns>是否支持</returns>
        </member>
        <member name="M:CatLib.Encryption.Encrypter.MakeEncrypter(System.String)">
            <summary>
            根据加密方式生成加密器
            </summary>
            <param name="cipher">加密方式</param>
        </member>
        <member name="T:CatLib.Encryption.EncryptionProvider">
            <summary>
            加解密服务
            </summary>
        </member>
        <member name="P:CatLib.Encryption.EncryptionProvider.Key">
            <summary>
            密钥
            </summary>
        </member>
        <member name="P:CatLib.Encryption.EncryptionProvider.Cipher">
            <summary>
            加密类型
            </summary>
        </member>
        <member name="F:CatLib.Encryption.EncryptionProvider.Encoding">
            <summary>
            密钥编码
            </summary>
        </member>
        <member name="M:CatLib.Encryption.EncryptionProvider.#ctor">
            <summary>
            加解密服务
            </summary>
        </member>
        <member name="M:CatLib.Encryption.EncryptionProvider.Init">
            <summary>
            服务提供者初始化
            </summary>
        </member>
        <member name="M:CatLib.Encryption.EncryptionProvider.Register">
            <summary>
            当注册服务提供者
            </summary>
        </member>
        <member name="T:CatLib.Facade.I18N">
            <summary>
            国际化I18N
            </summary>
        </member>
        <member name="T:CatLib.Facade.Json">
            <summary>
            Json
            </summary>
        </member>
        <member name="T:CatLib.Facade.Config">
            <summary>
            配置管理器
            </summary>
        </member>
        <member name="T:CatLib.Facade.FileSystem">
            <summary>
            文件系统管理器
            </summary>
        </member>
        <member name="T:CatLib.Facade.Router">
            <summary>
            路由
            </summary>
        </member>
        <member name="T:CatLib.Config.ConfigManager">
            <summary>
            配置管理器
            </summary>
        </member>
        <member name="F:CatLib.Config.ConfigManager.defaultName">
            <summary>
            默认的配置名字
            </summary>
        </member>
        <member name="F:CatLib.Config.ConfigManager.target">
            <summary>
            扫描目标
            </summary>
        </member>
        <member name="M:CatLib.Config.ConfigManager.#ctor">
            <summary>
            配置管理器
            </summary>
        </member>
        <member name="M:CatLib.Config.ConfigManager.SetDefault(System.String)">
            <summary>
            设定默认的配置名字
            </summary>
            <param name="name">默认配置名字</param>
        </member>
        <member name="M:CatLib.Config.ConfigManager.GetDefaultName">
            <summary>
            获取默认的配置名字
            </summary>
            <returns>默认的文件系统名字</returns>
        </member>
        <member name="M:CatLib.Config.ConfigManager.Config(System.Object,System.String)">
            <summary>
            对目标实例注入配置
            </summary>
            <param name="instance">实例</param>
            <param name="name">使用的配置容器名字</param>
        </member>
        <member name="T:CatLib.Config.Locator.CodeConfigLocator">
            <summary>
            代码配置定位器
            </summary>
        </member>
        <member name="F:CatLib.Config.Locator.CodeConfigLocator.dict">
            <summary>
            配置字典
            </summary>
        </member>
        <member name="M:CatLib.Config.Locator.CodeConfigLocator.#ctor">
            <summary>
            代码配置定位器
            </summary>
        </member>
        <member name="M:CatLib.Config.Locator.CodeConfigLocator.Set(System.String,System.String)">
            <summary>
            设定值
            </summary>
            <param name="name">配置名</param>
            <param name="value">配置值</param>
        </member>
        <member name="M:CatLib.Config.Locator.CodeConfigLocator.TryGetValue(System.String,System.String@)">
            <summary>
            根据配置名获取配置的值
            </summary>
            <param name="name">配置名</param>
            <param name="value">配置值</param>
            <returns>是否获取到配置</returns>
        </member>
        <member name="M:CatLib.Config.Locator.CodeConfigLocator.Save">
            <summary>
            保存配置
            </summary>
        </member>
        <member name="T:CatLib.Config.Config">
            <summary>
            配置容器
            </summary>
        </member>
        <member name="F:CatLib.Config.Config.locator">
            <summary>
            配置定位器
            </summary>
        </member>
        <member name="F:CatLib.Config.Config.converters">
            <summary>
            类型转换器
            </summary>
        </member>
        <member name="F:CatLib.Config.Config.watches">
            <summary>
            观察者
            </summary>
        </member>
        <member name="M:CatLib.Config.Config.#ctor(CatLib.API.Converters.IConverters,CatLib.API.Config.IConfigLocator)">
            <summary>
            构造配置容器
            </summary>
            <param name="converters">转换器</param>
            <param name="locator">配置定位器</param>
        </member>
        <member name="M:CatLib.Config.Config.SetConverters(CatLib.API.Converters.IConverters)">
            <summary>
            设定类型转换器
            </summary>
            <param name="converters">转换器</param>
        </member>
        <member name="M:CatLib.Config.Config.SetLocator(CatLib.API.Config.IConfigLocator)">
            <summary>
            注册一个配置定位器
            </summary>
            <param name="locator">配置定位器</param>
        </member>
        <member name="M:CatLib.Config.Config.Watch(System.String,System.Action{System.Object})">
            <summary>
            监控一个配置的变化
            </summary>
            <param name="name">监控的名字</param>
            <param name="callback">发生变化时会触发</param>
        </member>
        <member name="M:CatLib.Config.Config.Save">
            <summary>
            保存配置
            </summary>
        </member>
        <member name="P:CatLib.Config.Config.Item(System.String)">
            <summary>
            根据配置名获取配置
            </summary>
            <param name="name">配置名</param>
            <returns>配置的值</returns>
        </member>
        <member name="M:CatLib.Config.Config.Set(System.String,System.Object)">
            <summary>
            设定配置的值
            </summary>
            <param name="name">配置名</param>
            <param name="value">配置的值</param>
        </member>
        <member name="M:CatLib.Config.Config.Get(System.String,System.Type,System.Object)">
            <summary>
            根据配置名获取配置
            </summary>
            <param name="name">配置所属类型的名字</param>
            <param name="type">配置最终转换到的类型</param>
            <param name="def">当找不到配置时的默认值</param>
            <returns>配置的值，如果找不到则返回默认值</returns>
        </member>
        <member name="M:CatLib.Config.Config.Get``1(System.String,``0)">
            <summary>
            根据配置名获取配置
            </summary>
            <typeparam name="T">配置最终转换到的类型</typeparam>
            <param name="name">配置所属类型的名字</param>
            <param name="def">当找不到配置时的默认值</param>
            <returns>配置的值，如果找不到则返回默认值</returns>
        </member>
        <member name="T:CatLib.Config.ConfigProvider">
            <summary>
            配置服务提供者
            </summary>
        </member>
        <member name="M:CatLib.Config.ConfigProvider.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:CatLib.Config.ConfigProvider.Register">
            <summary>
            注册配置服务
            </summary>
        </member>
        <member name="M:CatLib.Config.ConfigProvider.RegisterManager">
            <summary>
            注册管理器
            </summary>
        </member>
        <member name="M:CatLib.Config.ConfigProvider.RegisterDefaultConfig">
            <summary>
            注册默认的配置
            </summary>
        </member>
        <member name="T:CatLib.Events.Dispatcher">
            <summary>
            事件调度器
            </summary>
        </member>
        <member name="F:CatLib.Events.Dispatcher.handlers">
            <summary>
            事件句柄
            </summary>
        </member>
        <member name="F:CatLib.Events.Dispatcher.wildcardHandlers">
            <summary>
            通配符事件句柄
            </summary>
        </member>
        <member name="F:CatLib.Events.Dispatcher.actionMapping">
            <summary>
            Action对应Func映射
            </summary>
        </member>
        <member name="F:CatLib.Events.Dispatcher.syncRoot">
            <summary>
            同步锁
            </summary>
        </member>
        <member name="F:CatLib.Events.Dispatcher.breakFlag">
            <summary>
            跳出标记
            </summary>
        </member>
        <member name="M:CatLib.Events.Dispatcher.#ctor">
            <summary>
            调度器
            </summary>
        </member>
        <member name="M:CatLib.Events.Dispatcher.Trigger(System.String,System.Object)">
            <summary>
            触发一个事件,并获取事件的返回结果
            </summary>
            <param name="eventName">事件名称</param>
            <param name="payload">载荷</param>
            <returns>事件结果</returns>
        </member>
        <member name="M:CatLib.Events.Dispatcher.TriggerHalt(System.String,System.Object)">
            <summary>
            触发一个事件,遇到第一个事件存在处理结果后终止,并获取事件的返回结果
            </summary>
            <param name="eventName">事件名</param>
            <param name="payload">载荷</param>
            <returns>事件结果</returns>
        </member>
        <member name="M:CatLib.Events.Dispatcher.Dispatch(System.String,System.Object,System.Boolean)">
            <summary>
            调度事件
            </summary>
            <param name="eventName">事件名</param>
            <param name="payload">载荷</param>
            <param name="halt">遇到第一个事件存在处理结果后终止</param>
            <returns>处理结果</returns>
        </member>
        <member name="M:CatLib.Events.Dispatcher.On(System.String,System.Action{System.Object},System.Int32)">
            <summary>
            注册一个事件
            </summary>
            <param name="eventName">事件名称</param>
            <param name="handler">事件句柄</param>
            <param name="life">在几次后事件会被自动释放</param>
            <returns>事件句柄</returns>
        </member>
        <member name="M:CatLib.Events.Dispatcher.Listen(System.String,System.Func{System.Object,System.Object},System.Int32)">
            <summary>
            注册一个事件
            </summary>
            <param name="eventName">事件名称</param>
            <param name="handler">事件句柄</param>
            <param name="life">在几次后事件会被自动释放</param>
            <returns>事件句柄</returns>
        </member>
        <member name="M:CatLib.Events.Dispatcher.Off(System.String,System.Action{System.Object})">
            <summary>
            反注册一个事件
            </summary>
            <param name="eventName">事件名</param>
            <param name="handler">事件句柄</param>
        </member>
        <member name="M:CatLib.Events.Dispatcher.WalkActionMapping(System.Action{System.Object},System.Action{System.Func{System.Object,System.Object}})">
            <summary>
            遍历行为映射
            </summary>
            <param name="handler">事件句柄</param>
            <param name="callback">回调</param>
        </member>
        <member name="M:CatLib.Events.Dispatcher.Off(CatLib.Events.EventHandler)">
            <summary>
            移除一个事件
            </summary>
            <param name="handler">事件句柄</param>
        </member>
        <member name="M:CatLib.Events.Dispatcher.SetWildcardListener(CatLib.Events.EventHandler)">
            <summary>
            设定通配符监听
            </summary>
            <param name="handler">监听句柄</param>
        </member>
        <member name="M:CatLib.Events.Dispatcher.GetListeners(System.String)">
            <summary>
            获取指定事件的事件句柄列表
            </summary>
            <param name="eventName">事件名</param>
            <returns>句柄列表</returns>
        </member>
        <member name="M:CatLib.Events.Dispatcher.Normalize(System.String)">
            <summary>
            标准化字符串
            </summary>
            <param name="input">输入</param>
            <returns>输出</returns>
        </member>
        <member name="T:CatLib.Events.EventHandler">
            <summary>
            事件句柄
            </summary>
        </member>
        <member name="P:CatLib.Events.EventHandler.Life">
            <summary>
            剩余的调用次数
            </summary>
        </member>
        <member name="P:CatLib.Events.EventHandler.IsLife">
            <summary>
            事件是否是有效的
            </summary>
        </member>
        <member name="P:CatLib.Events.EventHandler.EventName">
            <summary>
            事件名
            </summary>
        </member>
        <member name="P:CatLib.Events.EventHandler.IsWildcard">
            <summary>
            是否使用了通配符
            </summary>
        </member>
        <member name="F:CatLib.Events.EventHandler.dispatcher">
            <summary>
            调度器
            </summary>
        </member>
        <member name="F:CatLib.Events.EventHandler.handler">
            <summary>
            事件句柄
            </summary>
        </member>
        <member name="F:CatLib.Events.EventHandler.isCancel">
            <summary>
            是否取消事件
            </summary>
        </member>
        <member name="F:CatLib.Events.EventHandler.count">
            <summary>
            调用计数
            </summary>
        </member>
        <member name="M:CatLib.Events.EventHandler.#ctor(CatLib.Events.Dispatcher,System.String,System.Func{System.Object,System.Object},System.Int32,System.Boolean)">
            <summary>
            创建一个事件句柄
            </summary>
            <param name="dispatcher">调度器</param>
            <param name="eventName">事件名</param>
            <param name="handler">事件句柄</param>
            <param name="life">生命次数</param>
            <param name="wildcard">是否使用了通配符</param>
        </member>
        <member name="M:CatLib.Events.EventHandler.Off">
            <summary>
            撤销事件监听
            </summary>
            <returns>是否撤销成功</returns>
        </member>
        <member name="M:CatLib.Events.EventHandler.Is(System.Func{System.Object,System.Object})">
            <summary>
            是否是指定事件句柄
            </summary>
            <param name="handler">事件句柄</param>
            <returns>是否是</returns>
        </member>
        <member name="M:CatLib.Events.EventHandler.Trigger(System.Object)">
            <summary>
            激活事件
            </summary>
            <param name="payload">载荷</param>
        </member>
        <member name="T:CatLib.Events.EventsProvider">
            <summary>
            事件服务提供者
            </summary>
        </member>
        <member name="M:CatLib.Events.EventsProvider.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:CatLib.Events.EventsProvider.Register">
            <summary>
            注册事件服务
            </summary>
        </member>
        <member name="T:CatLib.FileSystem.Adapter.Local">
            <summary>
            本地驱动器
            </summary>
        </member>
        <member name="F:CatLib.FileSystem.Adapter.Local.root">
            <summary>
            根目录
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.#ctor(System.String)">
            <summary>
            构建一个本地驱动器
            </summary>
            <param name="root">根目录</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.Exists(System.String)">
            <summary>
            文件或文件夹是否存在
            </summary>
            <param name="path">文件或文件夹是否存在</param>
            <returns>是否存在</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.Write(System.String,System.Byte[])">
            <summary>
            写入数据
            如果数据已经存在则覆盖
            </summary>
            <param name="path">路径</param>
            <param name="contents">写入数据</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.Read(System.String)">
            <summary>
            读取文件
            </summary>
            <param name="path">路径</param>
            <returns>读取的数据</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.Move(System.String,System.String)">
            <summary>
            移动文件到指定目录(可以被用于重命名)
            </summary>
            <param name="path">旧的文件/文件夹路径</param>
            <param name="newPath">新的文件/文件夹路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.Copy(System.String,System.String)">
            <summary>
            复制文件或文件夹到指定路径
            </summary>
            <param name="path">文件或文件夹路径(应该包含文件夹或者文件名)</param>
            <param name="copyPath">复制到的路径(不应该包含文件夹或者文件名)</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.Delete(System.String)">
            <summary>
            删除文件或者文件夹
            </summary>
            <param name="path">路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.MakeDir(System.String)">
            <summary>
            创建文件夹
            </summary>
            <param name="path">文件夹路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.GetAttributes(System.String)">
            <summary>
            获取文件/文件夹属性
            </summary>
            <param name="path">文件/文件夹路径</param>
            <returns>文件/文件夹属性</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.GetList(System.String)">
            <summary>
            获取列表（不会迭代子文件夹）
            </summary>
            <param name="path">要获取列表的路径</param>
            <returns>指定目录下的文件夹和文件列表</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.GetSize(System.String)">
            <summary>
            获取文件/文件夹的大小(字节)
            </summary>
            <param name="path">文件/文件夹路径</param>
            <returns>文件/文件夹的大小</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.IsDir(System.String)">
            <summary>
            是否是文件夹
            </summary>
            <param name="path">文件/文件夹路径</param>
            <returns>是否是文件夹</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.Normalize(System.String)">
            <summary>
            标准化路径
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.GuardLimitedRoot(System.String)">
            <summary>
            判断限定范围是否在root下
            </summary>
            <param name="path">绝对路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.Local.EnsureDirectory(System.String)">
            <summary>
            保证目录存在
            </summary>
            <param name="root">路径</param>
        </member>
        <member name="T:CatLib.FileSystem.Adapter.IFileSystemAdapter">
            <summary>
            文件系统适配器
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.Exists(System.String)">
            <summary>
            文件或文件夹是否存在
            </summary>
            <param name="path">文件或文件夹是否存在</param>
            <returns>是否存在</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.Write(System.String,System.Byte[])">
            <summary>
            写入数据
            如果数据已经存在则覆盖
            </summary>
            <param name="path">路径</param>
            <param name="contents">写入数据</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.Read(System.String)">
            <summary>
            读取文件
            </summary>
            <param name="path">路径</param>
            <returns>读取的数据</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.Move(System.String,System.String)">
            <summary>
            移动文件到指定目录
            </summary>
            <param name="path">旧的文件/文件夹路径</param>
            <param name="newPath">新的文件/文件夹路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.Copy(System.String,System.String)">
            <summary>
            复制文件或文件夹到指定路径
            </summary>
            <param name="path">文件或文件夹路径(应该包含文件夹或者文件名)</param>
            <param name="copyPath">复制到的路径(不应该包含文件夹或者文件名)</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.Delete(System.String)">
            <summary>
            删除文件或者文件夹
            </summary>
            <param name="path">路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.MakeDir(System.String)">
            <summary>
            创建文件夹
            </summary>
            <param name="path">文件夹路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.GetAttributes(System.String)">
            <summary>
            获取文件/文件夹属性
            </summary>
            <param name="path">文件/文件夹路径</param>
            <returns>文件/文件夹属性</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.GetList(System.String)">
            <summary>
            获取列表（不会迭代子文件夹）
            </summary>
            <param name="path">要获取列表的文件夹路径(如果传入的是一个文件那么将会返回文件自身路径)</param>
            <returns>指定目录下的文件夹和文件列表</returns>
        </member>
        <member name="M:CatLib.FileSystem.Adapter.IFileSystemAdapter.GetSize(System.String)">
            <summary>
            获取文件/文件夹的大小(字节)
            </summary>
            <param name="path">文件/文件夹的路径</param>
            <returns>文件/文件夹的大小</returns>
        </member>
        <member name="T:CatLib.FileSystem.Directory">
            <summary>
            文件夹
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.Directory.#ctor(CatLib.FileSystem.FileSystem,System.String)">
            <summary>
            文件夹
            </summary>
            <param name="fileSystem">文件系统</param>
            <param name="path">文件夹路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Directory.GetList">
            <summary>
            获取文件夹下的文件/文件夹列表（不会迭代子文件夹）
            </summary>
            <returns>指定目录下的文件夹句柄和文件句柄列表</returns>
        </member>
        <member name="T:CatLib.FileSystem.File">
            <summary>
            文件
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.File.#ctor(CatLib.FileSystem.FileSystem,System.String)">
            <summary>
            文件
            </summary>
            <param name="fileSystem">文件系统</param>
            <param name="path">文件路径</param>
        </member>
        <member name="M:CatLib.FileSystem.File.Write(System.Byte[])">
            <summary>
            写入数据
            如果数据已经存在则覆盖
            </summary>
            <param name="contents">写入数据</param>
        </member>
        <member name="M:CatLib.FileSystem.File.Read">
            <summary>
            读取文件
            </summary>
            <returns>读取的数据</returns>
        </member>
        <member name="T:CatLib.FileSystem.FileSystem">
            <summary>
            文件系统
            </summary>
        </member>
        <member name="F:CatLib.FileSystem.FileSystem.adapter">
            <summary>
            文件系统适配器
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.#ctor(CatLib.FileSystem.Adapter.IFileSystemAdapter)">
            <summary>
            文件系统
            </summary>
            <param name="adapter">适配器</param>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.Exists(System.String)">
            <summary>
            文件或文件夹是否存在
            </summary>
            <param name="path">文件或文件夹是否存在</param>
            <returns>是否存在</returns>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.Write(System.String,System.Byte[])">
            <summary>
            写入数据
            如果数据已经存在则覆盖
            </summary>
            <param name="path">路径</param>
            <param name="contents">写入数据</param>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.Read(System.String)">
            <summary>
            读取文件
            </summary>
            <param name="path">路径</param>
            <returns>读取的数据</returns>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.Move(System.String,System.String)">
            <summary>
            移动文件到指定目录
            </summary>
            <param name="path">旧的文件/文件夹路径</param>
            <param name="newPath">新的文件/文件夹路径</param>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.Copy(System.String,System.String)">
            <summary>
            复制文件或文件夹到指定路径
            </summary>
            <param name="path">文件或文件夹路径(应该包含文件夹或者文件名)</param>
            <param name="copyPath">复制到的路径(不应该包含文件夹或者文件名)</param>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.Delete(System.String)">
            <summary>
            删除文件或者文件夹
            </summary>
            <param name="path">路径</param>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.MakeDir(System.String)">
            <summary>
            创建文件夹
            </summary>
            <param name="path">文件夹路径</param>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.GetAttributes(System.String)">
            <summary>
            获取文件/文件夹属性
            </summary>
            <param name="path">文件/文件夹路径</param>
            <returns>文件/文件夹属性</returns>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.GetSize(System.String)">
            <summary>
            获取文件/文件夹的大小(字节)
            </summary>
            <param name="path">文件/文件夹路径</param>
            <returns>文件/文件夹的大小</returns>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.GetHandler``1(System.String)">
            <summary>
            获取文件/文件夹句柄
            </summary>
            <param name="path">文件/文件夹路径</param>
            <returns>文件/文件夹句柄</returns>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.GetList(System.String)">
            <summary>
            获取列表（不会迭代子文件夹）
            </summary>
            <param name="path">要获取列表的文件夹路径(如果传入的是一个文件那么将会返回文件自身路径)</param>
            <returns>指定目录下的文件夹句柄和文件句柄列表</returns>
        </member>
        <member name="M:CatLib.FileSystem.FileSystem.IsDir(System.String)">
            <summary>
            是否是文件夹
            </summary>
            <param name="path">文件/文件夹路径</param>
            <returns>是否是文件夹</returns>
        </member>
        <member name="T:CatLib.FileSystem.FileSystemProvider">
            <summary>
            文件系统服务提供者
            </summary>
        </member>
        <member name="P:CatLib.FileSystem.FileSystemProvider.DefaultDevice">
            <summary>
            默认驱动名字
            </summary>
        </member>
        <member name="P:CatLib.FileSystem.FileSystemProvider.DefaultPath">
            <summary>
            默认路径
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemProvider.#ctor">
            <summary>
            文件系统服务提供者
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemProvider.Init">
            <summary>
            服务提供者进程
            </summary>
            <returns>迭代器</returns>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemProvider.Register">
            <summary>
            注册文件系统服务
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemProvider.RegisterManager">
            <summary>
            注册管理器
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemProvider.RegisterDefaultFileSystem">
            <summary>
            注册默认的文件系统
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemProvider.InitRegisterLocalDriver">
            <summary>
            初始化本地磁盘驱动
            </summary>
        </member>
        <member name="T:CatLib.FileSystem.Handler">
            <summary>
            文件/文件夹句柄
            </summary>
        </member>
        <member name="F:CatLib.FileSystem.Handler.path">
            <summary>
            文件/文件夹路径
            </summary>
        </member>
        <member name="P:CatLib.FileSystem.Handler.Path">
            <summary>
            文件/文件夹路径
            </summary>
        </member>
        <member name="F:CatLib.FileSystem.Handler.fileSystem">
            <summary>
            文件系统
            </summary>
        </member>
        <member name="P:CatLib.FileSystem.Handler.FileSystem">
            <summary>
            文件系统
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.Handler.#ctor(CatLib.FileSystem.FileSystem,System.String)">
            <summary>
            构造一个文件文件夹句柄
            </summary>
            <param name="fileSystem">文件系统</param>
            <param name="path">文件/文件夹路径</param>
        </member>
        <member name="M:CatLib.FileSystem.Handler.Copy(System.String)">
            <summary>
            复制文件或文件夹到指定路径
            </summary>
            <param name="copyPath">复制到的路径(不应该包含文件夹或者文件名)</param>
        </member>
        <member name="M:CatLib.FileSystem.Handler.Delete">
            <summary>
            删除文件或者文件夹
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.Handler.Rename(System.String)">
            <summary>
            重命名
            </summary>
            <param name="newName">新的文件/文件夹名字</param>
        </member>
        <member name="M:CatLib.FileSystem.Handler.Move(System.String)">
            <summary>
            将文件/文件夹移动到指定路径
            </summary>
            <param name="newPath">移动到的目标路径</param>
        </member>
        <member name="P:CatLib.FileSystem.Handler.IsExists">
            <summary>
            文件/文件夹是否存在
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.Handler.GetAttributes">
            <summary>
            获取文件/文件夹属性
            </summary>
            <returns>文件/文件夹属性</returns>
        </member>
        <member name="P:CatLib.FileSystem.Handler.IsDir">
            <summary>
            是否是文件夹
            </summary>
            <returns>是否是文件夹</returns>
        </member>
        <member name="M:CatLib.FileSystem.Handler.GetSize">
            <summary>
            获取文件/文件夹大小(字节)
            </summary>
            <returns>文件/文件夹大小</returns>
        </member>
        <member name="T:CatLib.FileSystem.FileSystemManager">
            <summary>
            文件系统管理器
            </summary>
        </member>
        <member name="F:CatLib.FileSystem.FileSystemManager.name">
            <summary>
            默认名字
            </summary>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemManager.SetDefaultDevice(System.String)">
            <summary>
            设定默认驱动名字
            </summary>
            <param name="name">默认驱动名字</param>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemManager.Disk(System.String)">
            <summary>
            获取一个文件系统(磁盘)
            </summary>
            <param name="name">名字</param>
            <returns>文件系统</returns>
        </member>
        <member name="M:CatLib.FileSystem.FileSystemManager.GetDefaultName">
            <summary>
            获取默认的文件系统名字
            </summary>
            <returns>默认的文件系统名字</returns>
        </member>
        <member name="T:CatLib.Hashing.Checksum.Adler32">
            <summary>
            Adler32校验
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Checksum.Adler32.Base">
            <summary>
            最大素数
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Checksum.Adler32.checkValue">
            <summary>
            校验和
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Adler32.#ctor">
            <summary>
            构建一个Adler32校验
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Adler32.Reset">
            <summary>
            重置数据校验，恢复到初始状态
            </summary>
        </member>
        <member name="P:CatLib.Hashing.Checksum.Adler32.Value">
            <summary>
            返回Adler32校验和
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Adler32.Update(System.Int32)">
            <summary>
            使用输入值更新校验和
            </summary>
            <param name="bval">要添加的数据，int的高字节被忽略</param>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Adler32.Update(System.Byte[])">
            <summary>
            使用传入的字节数组更新数据校验和
            </summary>
            <param name="buffer">字节数组</param>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将字节数组添加到数据校验和
            </summary>
            <param name="buffer">字节数组</param>
            <param name="offset">起始偏移量</param>
            <param name="count">多少长度会被添加到数据校验</param>
        </member>
        <member name="T:CatLib.Hashing.Checksum.Crc32">
            <summary>
            Crc32校验
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Checksum.Crc32.CrcInit">
            <summary>
            Crc初始化
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Checksum.Crc32.CrcXor">
            <summary>
            Crc异或运算
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Checksum.Crc32.table">
            <summary>
            校验表
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Checksum.Crc32.checkValue">
            <summary>
            校验和
            </summary>
        </member>
        <member name="P:CatLib.Hashing.Checksum.Crc32.Value">
            <summary>
            校验和
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Crc32.#ctor">
            <summary>
            Crc32实例
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Crc32.Reset">
            <summary>
            重置数据校验，恢复到初始状态
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Crc32.Update(System.Int32)">
            <summary>
            添加数据进行校验
            </summary>
            <param name = "bval">要添加的数据，int的高字节被忽略</param>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Crc32.Update(System.Byte[])">
            <summary>
            使用传入的字节数组更新数据校验和
            </summary>
            <param name="buffer">字节数组</param>
        </member>
        <member name="M:CatLib.Hashing.Checksum.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            对字节数组进行校验
            </summary>
            <param name="buffer">字节数组</param>
            <param name="offset">偏移量</param>
            <param name="count">长度</param>
        </member>
        <member name="T:CatLib.Hashing.Checksum.IChecksum">
            <summary>
            校验接口
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Checksum.IChecksum.Reset">
            <summary>
            重置数据校验，恢复到初始状态
            </summary>
        </member>
        <member name="P:CatLib.Hashing.Checksum.IChecksum.Value">
            <summary>
            返回到目前为止计算的数据校验和
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Checksum.IChecksum.Update(System.Int32)">
            <summary>
            增加一个字节的校验
            </summary>
            <param name="bval">要添加的数据，int的高字节被忽略</param>
        </member>
        <member name="M:CatLib.Hashing.Checksum.IChecksum.Update(System.Byte[])">
            <summary>
            使用传入的字节数组更新数据校验和
            </summary>
            <param name="buffer">字节数组</param>
        </member>
        <member name="M:CatLib.Hashing.Checksum.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将字节数组添加到数据校验和
            </summary>
            <param name="buffer">字节数组</param>
            <param name="offset">起始偏移量</param>
            <param name="count">多少长度会被添加到数据校验</param>
        </member>
        <member name="T:CatLib.Hashing.Hashing">
            <summary>
            哈希
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Hashing.checksumsMaker">
            <summary>
            校验类字典
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Hashing.hashByteMaker">
            <summary>
            非加密哈希字典
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Hashing.checksumsDict">
            <summary>
            校验类字典
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Hashing.hashByteDict">
            <summary>
            非加密哈希字典
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Hashing.syncRoot">
            <summary>
            同步锁
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Hashing.defaultChecksum">
            <summary>
            默认的校验算法
            </summary>
        </member>
        <member name="F:CatLib.Hashing.Hashing.defaultHash">
            <summary>
            默认的哈希算法
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Hashing.#ctor(CatLib.API.Hashing.Checksums,CatLib.API.Hashing.Hashes)">
            <summary>
            哈希
            </summary>
        </member>
        <member name="M:CatLib.Hashing.Hashing.RegisterChecksum(CatLib.API.Hashing.Checksums,System.Func{CatLib.Hashing.Checksum.IChecksum})">
            <summary>
            注册校验算法
            </summary>
            <param name="checksum">校验类类型</param>
            <param name="builder">构建器</param>
        </member>
        <member name="M:CatLib.Hashing.Hashing.RegisterHash(CatLib.API.Hashing.Hashes,System.Func{System.Security.Cryptography.HashAlgorithm})">
            <summary>
            注册校验算法
            </summary>
            <param name="hash">哈希类类型</param>
            <param name="builder">构建器</param>
        </member>
        <member name="M:CatLib.Hashing.Hashing.Checksum(System.Byte[])">
            <summary>
            使用默认的校验算法计算校验和
            </summary>
            <param name="buffer">字节数组</param>
            <returns>校验和</returns>
        </member>
        <member name="M:CatLib.Hashing.Hashing.Checksum(System.Byte[],CatLib.API.Hashing.Checksums)">
            <summary>
            计算校验和
            </summary>
            <param name="buffer">字节数组</param>
            <param name="checksum">使用校验类类型</param>
            <returns>校验和</returns>
        </member>
        <member name="M:CatLib.Hashing.Hashing.HashPassword(System.String,System.Int32)">
            <summary>
            对输入值进行加密性Hash
            </summary>
            <param name="input">输入值</param>
            <param name="factor">加密因子</param>
            <returns>哈希值</returns>
        </member>
        <member name="M:CatLib.Hashing.Hashing.CheckPassword(System.String,System.String)">
            <summary>
            验证输入值和加密性哈希值是否匹配
            </summary>
            <param name="input">输入值</param>
            <param name="hash">哈希值</param>
            <returns>是否匹配</returns>
        </member>
        <member name="M:CatLib.Hashing.Hashing.HashString(System.String)">
            <summary>
            对输入值进行非加密哈希
            </summary>
            <param name="input">输入值</param>
            <returns>哈希值</returns>
        </member>
        <member name="M:CatLib.Hashing.Hashing.HashString(System.String,CatLib.API.Hashing.Hashes)">
            <summary>
            对输入值进行非加密哈希
            </summary>
            <param name="input">输入值</param>
            <param name="hash">使用的哈希算法</param>
            <returns>哈希值</returns>
        </member>
        <member name="M:CatLib.Hashing.Hashing.HashString(System.String,System.Text.Encoding,CatLib.API.Hashing.Hashes)">
            <summary>
            对输入值进行非加密哈希
            </summary>
            <param name="input">输入值</param>
            <param name="encoding">编码</param>
            <param name="hash">使用的哈希算法</param>
            <returns>哈希值</returns>
        </member>
        <member name="M:CatLib.Hashing.Hashing.HashByte(System.Byte[])">
            <summary>
            对输入值进行非加密哈希
            </summary>
            <param name="input">输入值</param>
            <returns>哈希值</returns>
        </member>
        <member name="M:CatLib.Hashing.Hashing.HashByte(System.Byte[],CatLib.API.Hashing.Hashes)">
            <summary>
            对输入值进行非加密哈希
            </summary>
            <param name="input">输入值</param>
            <param name="hash">使用的哈希算法</param>
            <returns>哈希值</returns>
        </member>
        <member name="T:CatLib.Hashing.HashingProvider">
            <summary>
            哈希服务提供者
            </summary>
        </member>
        <member name="P:CatLib.Hashing.HashingProvider.DefaultChecksum">
            <summary>
            默认的校验类
            </summary>
        </member>
        <member name="P:CatLib.Hashing.HashingProvider.DefaultHash">
            <summary>
            默认的哈希类
            </summary>
        </member>
        <member name="M:CatLib.Hashing.HashingProvider.#ctor">
            <summary>
            哈希服务提供者
            </summary>
        </member>
        <member name="M:CatLib.Hashing.HashingProvider.Init">
            <summary>
            服务提供者初始化
            </summary>
        </member>
        <member name="M:CatLib.Hashing.HashingProvider.Register">
            <summary>
            当注册服务提供者
            </summary>
        </member>
        <member name="T:CatLib.Hashing.HashString.DjbHash">
            <summary>
            Djb Hash
            </summary>
        </member>
        <member name="F:CatLib.Hashing.HashString.DjbHash.hash">
            <summary>
            Hash值
            </summary>
        </member>
        <member name="M:CatLib.Hashing.HashString.DjbHash.#ctor">
            <summary>
            Djb Hash
            </summary>
        </member>
        <member name="M:CatLib.Hashing.HashString.DjbHash.Initialize">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:CatLib.Hashing.HashString.DjbHash.Reset">
            <summary>
            重置
            </summary>
        </member>
        <member name="M:CatLib.Hashing.HashString.DjbHash.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>
            核心Hash算法
            </summary>
            <param name="array">Hash字节流</param>
            <param name="ibStart">起始</param>
            <param name="cbSize">长度</param>
        </member>
        <member name="M:CatLib.Hashing.HashString.DjbHash.HashFinal">
            <summary>
            Hash完成
            </summary>
            <returns>哈希值</returns>
        </member>
        <member name="T:CatLib.Json.JsonProvider">
            <summary>
            Json 服务
            </summary>
        </member>
        <member name="M:CatLib.Json.JsonProvider.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:CatLib.Json.JsonProvider.Register">
            <summary>
            当注册服务提供者
            </summary>
        </member>
        <member name="T:CatLib.Json.JsonUtility">
            <summary>
            Json处理器
            </summary>
        </member>
        <member name="F:CatLib.Json.JsonUtility.handler">
            <summary>
            处理器
            </summary>
        </member>
        <member name="M:CatLib.Json.JsonUtility.SetJson(CatLib.API.Json.IJson)">
            <summary>
            设定记录器实例接口
            </summary>
            <param name="handler">记录器</param>
        </member>
        <member name="M:CatLib.Json.JsonUtility.Decode``1(System.String)">
            <summary>
            反序列化
            </summary>
            <typeparam name="T">类型</typeparam>
            <param name="json">json数据</param>
            <returns>反序列化的类型</returns>
        </member>
        <member name="M:CatLib.Json.JsonUtility.Encode(System.Object)">
            <summary>
            序列化
            </summary>
            <param name="item">需要序列化的对象</param>
            <returns>json数据</returns>
        </member>
        <member name="M:CatLib.Json.JsonUtility.GuardHandler">
            <summary>
            校验json处理器有效性
            </summary>
        </member>
        <member name="T:CatLib.Json.SimpleJsonAdapter">
            <summary>
            Facebook Simple Json 适配器
            </summary>
        </member>
        <member name="M:CatLib.Json.SimpleJsonAdapter.Decode``1(System.String)">
            <summary>
            反序列化
            </summary>
            <typeparam name="T">类型</typeparam>
            <param name="json">json数据</param>
            <returns>反序列化的类型</returns>
        </member>
        <member name="M:CatLib.Json.SimpleJsonAdapter.Encode(System.Object)">
            <summary>
            序列化
            </summary>
            <param name="item">需要序列化的对象</param>
            <returns>json数据</returns>
        </member>
        <member name="T:CatLib.Random.RandomProvider">
            <summary>
            随机算法服务提供者
            </summary>
        </member>
        <member name="P:CatLib.Random.RandomProvider.DefaultRandomType">
            <summary>
            默认的随机算法
            </summary>
        </member>
        <member name="M:CatLib.Random.RandomProvider.#ctor">
            <summary>
            随机算法服务提供者
            </summary>
        </member>
        <member name="M:CatLib.Random.RandomProvider.Init">
            <summary>
            服务提供者初始化
            </summary>
        </member>
        <member name="M:CatLib.Random.RandomProvider.Register">
            <summary>
            当注册服务提供者
            </summary>
        </member>
        <member name="M:CatLib.Random.RandomProvider.InitedRandom(CatLib.Random.RandomFactory)">
            <summary>
            初始化随机库
            </summary>
            <param name="randomFactory">随机库</param>
        </member>
        <member name="T:CatLib.Random.RandomAdaptor">
            <summary>
            随机算法适配器
            </summary>
        </member>
        <member name="F:CatLib.Random.RandomAdaptor.random">
            <summary>
            随机算法
            </summary>
        </member>
        <member name="M:CatLib.Random.RandomAdaptor.#ctor(System.Random)">
            <summary>
            随机算法适配器
            </summary>
            <param name="random">随机算法</param>
        </member>
        <member name="M:CatLib.Random.RandomAdaptor.Next">
            <summary>
            返回一个随机数
            </summary>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomAdaptor.Next(System.Int32)">
            <summary>
            返回一个随机数
            </summary>
            <param name="maxValue">最小值</param>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomAdaptor.Next(System.Int32,System.Int32)">
            <summary>
            返回一个随机数
            </summary>
            <param name="minValue">最小值</param>
            <param name="maxValue">最大值</param>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomAdaptor.NextBytes(System.Byte[])">
            <summary>
            生成随机数填充流
            </summary>
            <param name="buffer">流</param>
        </member>
        <member name="M:CatLib.Random.RandomAdaptor.NextDouble">
            <summary>
            返回一个介于0到1之间的随机数
            </summary>
            <returns>随机数</returns>
        </member>
        <member name="T:CatLib.Random.RandomFactory">
            <summary>
            随机算法生成器
            </summary>
        </member>
        <member name="F:CatLib.Random.RandomFactory.randomsMaker">
            <summary>
            随机数算法构建器字典
            </summary>
        </member>
        <member name="F:CatLib.Random.RandomFactory.randomsCache">
            <summary>
            随机算法实例缓存
            </summary>
        </member>
        <member name="F:CatLib.Random.RandomFactory.defaultRandomType">
            <summary>
            默认的随机算法类型
            </summary>
        </member>
        <member name="M:CatLib.Random.RandomFactory.#ctor(CatLib.API.Random.RandomTypes)">
            <summary>
            构造一个随机算法生成器
            </summary>
            <param name="defaultType">默认的随机算法类型</param>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Make">
            <summary>
            生成随机算法
            </summary>
            <returns>随机数算法</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Make(CatLib.API.Random.RandomTypes)">
            <summary>
            生成随机算法
            </summary>
            <param name="type">算法类型</param>
            <returns>随机数算法</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Make(System.Int32,CatLib.API.Random.RandomTypes)">
            <summary>
            生成随机算法
            </summary>
            <returns>随机数算法</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Next">
            <summary>
            返回一个随机数
            </summary>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Next(CatLib.API.Random.RandomTypes)">
            <summary>
            返回一个随机数
            </summary>
            <param name="type">使用的随机算法类型</param>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Next(System.Int32)">
            <summary>
            返回一个随机数
            </summary>
            <param name="maxValue">最大值</param>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Next(System.Int32,CatLib.API.Random.RandomTypes)">
            <summary>
            返回一个随机数
            </summary>
            <param name="maxValue">最大值</param>
            <param name="type">使用的随机算法类型</param>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Next(System.Int32,System.Int32)">
            <summary>
            返回一个随机数
            </summary>
            <param name="minValue">最小值</param>
            <param name="maxValue">最大值</param>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.Next(System.Int32,System.Int32,CatLib.API.Random.RandomTypes)">
            <summary>
            返回一个随机数
            </summary>
            <param name="minValue">最小值</param>
            <param name="maxValue">最大值</param>
            <param name="type">使用的随机算法类型</param>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.NextBytes(System.Byte[])">
            <summary>
            生成随机数填充流
            </summary>
            <param name="buffer">流</param>
        </member>
        <member name="M:CatLib.Random.RandomFactory.NextBytes(System.Byte[],CatLib.API.Random.RandomTypes)">
            <summary>
            生成随机数填充流
            </summary>
            <param name="buffer">流</param>
            <param name="type">使用的随机算法类型</param>
        </member>
        <member name="M:CatLib.Random.RandomFactory.NextDouble">
            <summary>
            返回一个介于0到1之间的随机数
            </summary>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.NextDouble(CatLib.API.Random.RandomTypes)">
            <summary>
            返回一个介于0到1之间的随机数
            </summary>
            <param name="type">使用的随机算法类型</param>
            <returns>随机数</returns>
        </member>
        <member name="M:CatLib.Random.RandomFactory.RegisterRandom(CatLib.API.Random.RandomTypes,System.Func{System.Int32,CatLib.API.Random.IRandom})">
            <summary>
            注册随机数算法
            </summary>
            <param name="type">算法类型</param>
            <param name="builder">构建器</param>
        </member>
        <member name="M:CatLib.Random.RandomFactory.GetRandom(CatLib.API.Random.RandomTypes)">
            <summary>
            获取随机数算法
            </summary>
            <param name="type">算法类型</param>
            <returns>随机数算法</returns>
        </member>
        <member name="T:CatLib.Routing.ExceptionRequest">
            <summary>
            请求(由于某些异常导致请求都无法被构建所以我们提供一个必定可以被构建的请求类)
            </summary>
        </member>
        <member name="P:CatLib.Routing.ExceptionRequest.Uri">
            <summary>
            Uri
            </summary>
        </member>
        <member name="F:CatLib.Routing.ExceptionRequest.uri">
            <summary>
            访问uri
            </summary>
        </member>
        <member name="F:CatLib.Routing.ExceptionRequest.context">
            <summary>
            上下文
            </summary>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.#ctor(System.String,System.Object)">
            <summary>
            构建一个请求
            </summary>
            <param name="uri">uri</param>
            <param name="context">上下文</param>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetContext">
            <summary>
            获取上下文
            </summary>
            <returns>上下文</returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.Segment(System.Int32,System.String)">
            <summary>
            构成uri路径段的数组
            </summary>
            <param name="index">下标</param>
            <param name="defaultValue">默认值</param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.Get(System.String,System.String)">
            <summary>
            获取字符串附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.ReplaceParameter(System.String,System.String)">
            <summary>
            替换参数
            </summary>
            <param name="key">键</param>
            <param name="value">值</param>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.ReplaceContext(System.Object)">
            <summary>
            替换上下文
            </summary>
            <param name="context">上下文</param>
        </member>
        <member name="P:CatLib.Routing.ExceptionRequest.Item(System.String)">
            <summary>
            获取字符串附加物
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetString(System.String,System.String)">
            <summary>
            获取字符串附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetInt(System.String,System.Int32)">
            <summary>
            获取整型的附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetLong(System.String,System.Int64)">
            <summary>
            获取长整型的附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetShort(System.String,System.Int16)">
            <summary>
            获取短整型的附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetChar(System.String,System.Char)">
            <summary>
            获取字符的附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetFloat(System.String,System.Single)">
            <summary>
            获取浮点数的附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetDouble(System.String,System.Double)">
            <summary>
            获取双精度浮点数的附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.GetBoolean(System.String,System.Boolean)">
            <summary>
            获取布尔值的附加物
            </summary>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.ExceptionRequest.ToString">
            <summary>
            转为字符串
            </summary>
            <returns>uri</returns>
        </member>
        <member name="T:CatLib.Routing.RouterEvents">
            <summary>
            路由事件
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouterEvents.OnBeforeRouterAttrCompiler">
            <summary>
            当属性路由编译之前
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouterEvents.OnDispatcher">
            <summary>
            当路由调度之前
            </summary>
        </member>
        <member name="T:CatLib.Routing.AttrRouteCompiler">
            <summary>
            属性路由编译器
            </summary>
        </member>
        <member name="F:CatLib.Routing.AttrRouteCompiler.router">
            <summary>
            路由器
            </summary>
        </member>
        <member name="F:CatLib.Routing.AttrRouteCompiler.routed">
            <summary>
            被路由的特性标记
            </summary>
        </member>
        <member name="F:CatLib.Routing.AttrRouteCompiler.buildRecord">
            <summary>
            编译记录
            </summary>
        </member>
        <member name="F:CatLib.Routing.AttrRouteCompiler.controllerFuncBuildRecord">
            <summary>
            控制器编译记录
            </summary>
        </member>
        <member name="F:CatLib.Routing.AttrRouteCompiler.stripping">
            <summary>
            是否剥离当前程序集
            </summary>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.#ctor(CatLib.Routing.Router)">
            <summary>
            属性路由编译器
            </summary>
            <param name="router">路由器</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.OnStripping(System.Func{System.Reflection.Assembly,System.Boolean})">
            <summary>
            根据回调返回结果来决定是否对当前程序集进行属性路由扫描
            </summary>
            <param name="stripping">回调返回true表示跳过该程序集扫描</param>
            <returns>当前容器实例</returns>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.Complie">
            <summary>
            编译属性路由
            </summary>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ComplieRouted(System.Type)">
            <summary>
            编译属性路由
            </summary>
            <param name="type">编译类型</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ComplieController(System.Type,CatLib.API.Routing.RoutedAttribute)">
            <summary>
            编译控制器
            </summary>
            <param name="type">控制器类型</param>
            <param name="baseRouted">控制器路由标记</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ComplieFunction(System.Type,System.Reflection.MethodInfo,CatLib.API.Routing.RoutedAttribute)">
            <summary>
            编译函数
            </summary>
            <param name="controllerType">控制器类型</param>
            <param name="method">方法信息</param>
            <param name="baseRouted">控制器路由标记</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.CheckRepeat(System.String,System.Type,System.Reflection.MethodInfo)">
            <summary>
            检查是否重复编译
            </summary>
            <param name="path">编译路径</param>
            <param name="controllerType">控制器类型</param>
            <param name="method">编译方法</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ComplieOptions(CatLib.API.Routing.IRoute,CatLib.API.Routing.RoutedAttribute)">
            <summary>
            编译配置信息
            </summary>
            <param name="route">路由条目</param>
            <param name="routed">路由特性</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ComplieOptionsGroup(CatLib.API.Routing.IRoute,CatLib.API.Routing.RoutedAttribute)">
            <summary>
            增加组信息
            </summary>
            <param name="route">路由条目</param>
            <param name="routed">路由特性</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ComplieOptionsWhere(CatLib.API.Routing.IRoute,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            增加where信息
            </summary>
            <param name="route">路由条目</param>
            <param name="routed">路由特性</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ComplieOptionsDefaults(CatLib.API.Routing.IRoute,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            增加defaults信息
            </summary>
            <param name="route">路由条目</param>
            <param name="routed">路由特性</param>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ComplieDirection(System.String)">
            <summary>
            编译指向语法
            </summary>
            <param name="input">输入的字符串</param>
            <returns>解析的指向语法</returns>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.IsStripping(System.Reflection.Assembly)">
            <summary>
            程序集是否是被剥离的
            </summary>
            <param name="assembly">资源集</param>
            <returns>是否过滤</returns>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.ClassOrFunctionNameToRouteName(System.String)">
            <summary>
            类名或者方法名转为路由名
            </summary>
            <param name="name">名字</param>
            <returns>路由名</returns>
        </member>
        <member name="M:CatLib.Routing.AttrRouteCompiler.HasScheme(System.String)">
            <summary>
            是否包含scheme
            </summary>
            <param name="uri">输入值</param>
        </member>
        <member name="T:CatLib.Routing.CompiledRoute">
            <summary>
            编译后的路由信息
            </summary>
        </member>
        <member name="P:CatLib.Routing.CompiledRoute.StaticPrefix">
            <summary>
            静态文本
            </summary>
        </member>
        <member name="P:CatLib.Routing.CompiledRoute.RouteRegex">
            <summary>
            路由匹配表达式
            </summary>
        </member>
        <member name="P:CatLib.Routing.CompiledRoute.Tokens">
            <summary>
            所有需要匹配的变量单独的正则匹配式
            </summary>
        </member>
        <member name="P:CatLib.Routing.CompiledRoute.PathVariables">
            <summary>
            路径中的变量
            </summary>
        </member>
        <member name="P:CatLib.Routing.CompiledRoute.HostRegex">
            <summary>
            匹配host的表达式
            </summary>
        </member>
        <member name="P:CatLib.Routing.CompiledRoute.HostTokens">
            <summary>
            host部分的需要匹配变量单独的正则表达式
            </summary>
        </member>
        <member name="P:CatLib.Routing.CompiledRoute.HostVariables">
            <summary>
            匹配host的的变量名
            </summary>
        </member>
        <member name="P:CatLib.Routing.CompiledRoute.Variables">
            <summary>
            所有的变量列表
            </summary>
        </member>
        <member name="M:CatLib.Routing.CompiledRoute.ToString">
            <summary>
            转为字符串
            </summary>
            <returns>编译后的字符串表示信息</returns>
        </member>
        <member name="T:CatLib.Routing.Request">
            <summary>
            请求
            </summary>
        </member>
        <member name="F:CatLib.Routing.Request.uri">
            <summary>
            统一资源标识符
            </summary>
        </member>
        <member name="F:CatLib.Routing.Request.route">
            <summary>
            使用的路由
            </summary>
        </member>
        <member name="P:CatLib.Routing.Request.Route">
            <summary>
            属于的路由器
            </summary>
        </member>
        <member name="F:CatLib.Routing.Request.parameters">
            <summary>
            参数表
            </summary>
        </member>
        <member name="P:CatLib.Routing.Request.Uri">
            <summary>
            Uri
            </summary>
        </member>
        <member name="P:CatLib.Routing.Request.RouteUri">
            <summary>
            Uri
            </summary>
        </member>
        <member name="F:CatLib.Routing.Request.context">
            <summary>
            上下文
            </summary>
        </member>
        <member name="M:CatLib.Routing.Request.#ctor(System.String,System.Object)">
            <summary>
            构建一个请求
            </summary>
            <param name="uri"></param>
            <param name="context"></param>
        </member>
        <member name="M:CatLib.Routing.Request.Segment(System.Int32,System.String)">
            <summary>
            构成uri路径段的数组
            </summary>
            <param name="index">下标</param>
            <param name="defaultValue">默认值</param>
            <returns>路径段值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetContext">
            <summary>
            获取上下文
            </summary>
            <returns>请求上下文</returns>
        </member>
        <member name="M:CatLib.Routing.Request.ReplaceContext(System.Object)">
            <summary>
            替换上下文
            </summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:CatLib.Routing.Request.Get(System.String,System.String)">
            <summary>
            获取字符串附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.ReplaceParameter(System.String,System.String)">
            <summary>
            替换参数
            </summary>
            <param name="key">键</param>
            <param name="value">值</param>
        </member>
        <member name="P:CatLib.Routing.Request.Item(System.String)">
            <summary>
            获取字符串附加物
            </summary>
            <param name="key">键</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetString(System.String,System.String)">
            <summary>
            获取字符串附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetInt(System.String,System.Int32)">
            <summary>
            获取整型的附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetLong(System.String,System.Int64)">
            <summary>
            获取长整型的附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetShort(System.String,System.Int16)">
            <summary>
            获取短整型的附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetChar(System.String,System.Char)">
            <summary>
            获取字符的附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetFloat(System.String,System.Single)">
            <summary>
            获取浮点数的附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetDouble(System.String,System.Double)">
            <summary>
            获取双精度浮点数的附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.GetBoolean(System.String,System.Boolean)">
            <summary>
            获取布尔值的附加物
            </summary>
            <param name="key">键</param>
            <param name="defaultValue">默认值</param>
            <returns>值</returns>
        </member>
        <member name="M:CatLib.Routing.Request.SetParameters(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            设定参数
            </summary>
            <param name="parameters">参数字典</param>
        </member>
        <member name="M:CatLib.Routing.Request.SetRoute(CatLib.Routing.Route)">
            <summary>
            设定路由方案
            </summary>
            <param name="route">路由方案</param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.Request.ToString">
            <summary>
            转为字符串
            </summary>
            <returns>转为字符串</returns>
        </member>
        <member name="T:CatLib.Routing.Response">
            <summary>
            响应
            </summary>
        </member>
        <member name="F:CatLib.Routing.Response.context">
            <summary>
            上下文
            </summary>
        </member>
        <member name="M:CatLib.Routing.Response.GetContext">
            <summary>
            设定上下文
            </summary>
            <returns>上下文</returns>
        </member>
        <member name="M:CatLib.Routing.Response.SetContext(System.Object)">
            <summary>
            设定上下文
            </summary>
            <param name="context">上下文</param>
        </member>
        <member name="T:CatLib.Routing.Route">
            <summary>
            路由条目
            </summary>
        </member>
        <member name="F:CatLib.Routing.Route.validators">
            <summary>
            验证器
            </summary>
        </member>
        <member name="F:CatLib.Routing.Route.uri">
            <summary>
            统一资源标识
            </summary>
        </member>
        <member name="P:CatLib.Routing.Route.Uri">
            <summary>
            统一资源标识
            </summary>
        </member>
        <member name="F:CatLib.Routing.Route.router">
            <summary>
            路由器
            </summary>
        </member>
        <member name="F:CatLib.Routing.Route.options">
            <summary>
            路由配置
            </summary>
        </member>
        <member name="P:CatLib.Routing.Route.Options">
            <summary>
            路由配置
            </summary>
        </member>
        <member name="F:CatLib.Routing.Route.compiled">
            <summary>
            编译后的路由器信息
            </summary>
        </member>
        <member name="P:CatLib.Routing.Route.Compiled">
            <summary>
            编译后的路由器信息
            </summary>
        </member>
        <member name="F:CatLib.Routing.Route.container">
            <summary>
            容器
            </summary>
        </member>
        <member name="F:CatLib.Routing.Route.action">
            <summary>
            路由行为
            </summary>
        </member>
        <member name="M:CatLib.Routing.Route.#ctor(CatLib.Routing.Uri,CatLib.Routing.RouteAction)">
            <summary>
            创建一个新的路由条目
            </summary>
            <param name="uri">uri信息</param>
            <param name="action">路由行为</param>
        </member>
        <member name="M:CatLib.Routing.Route.SetContainer(CatLib.IContainer)">
            <summary>
            设定容器
            </summary>
            <param name="container">容器</param>
            <returns>当前路由条目</returns>
        </member>
        <member name="M:CatLib.Routing.Route.SetRouter(CatLib.Routing.Router)">
            <summary>
            设定路由器
            </summary>
            <param name="router">路由器</param>
            <returns>当前路由条目</returns>
        </member>
        <member name="M:CatLib.Routing.Route.GetDefaults(System.String,System.String)">
            <summary>
            获取参数默认值
            </summary>
            <param name="name">参数名</param>
            <param name="defaultValue">默认值</param>
        </member>
        <member name="M:CatLib.Routing.Route.GetWhere(System.String)">
            <summary>
            获取筛选条件
            </summary>
            <param name="varName">参数名</param>
            <returns>筛选条件</returns>
        </member>
        <member name="M:CatLib.Routing.Route.GetValidators">
            <summary>
            获取验证器列表
            </summary>
            <returns>验证器列表</returns>
        </member>
        <member name="M:CatLib.Routing.Route.Where(System.String,System.String,System.Boolean)">
            <summary>
            约束指定参数必须符合指定模式才会被路由
            </summary>
            <param name="name">名字</param>
            <param name="pattern">约束参数</param>
            <param name="overrided">是否覆盖</param>
            <returns>路由条目实例</returns>
        </member>
        <member name="M:CatLib.Routing.Route.Defaults(System.String,System.String,System.Boolean)">
            <summary>
            设定默认值
            </summary>
            <param name="name">参数名</param>
            <param name="val">默认值</param>
            <param name="overrided">是否覆盖</param>
            <returns>路由条目实例</returns>
        </member>
        <member name="M:CatLib.Routing.Route.Group(System.String)">
            <summary>
            将当前路由条目追加到指定路由组中
            </summary>
            <param name="name">名字</param>
            <returns>路由条目实例</returns>
        </member>
        <member name="M:CatLib.Routing.Route.OnError(System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception}},System.Int32)">
            <summary>
            当路由出现错误时
            </summary>
            <param name="onError">执行的处理函数</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>路由条目实例</returns>
        </member>
        <member name="M:CatLib.Routing.Route.Middleware(System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse}},System.Int32)">
            <summary>
            路由中间件
            </summary>
            <param name="middleware">执行的处理函数</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>路由条目实例</returns>
        </member>
        <member name="M:CatLib.Routing.Route.Run(CatLib.Routing.Request,CatLib.Routing.Response)">
            <summary>
            执行请求
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <returns>响应</returns>
        </member>
        <member name="M:CatLib.Routing.Route.GatherMiddleware">
            <summary>
            获取路由的中间件
            </summary>
            <returns>中间件过滤器链</returns>
        </member>
        <member name="M:CatLib.Routing.Route.GatherOnError">
            <summary>
            获取当出现错误时的过滤器链
            </summary>
            <returns>错误过滤器链</returns>
        </member>
        <member name="M:CatLib.Routing.Route.Matches(CatLib.Routing.Request)">
            <summary>
            当前路由条目是否符合请求
            </summary>
            <param name="request">请求</param>
            <returns>是否符合</returns>
        </member>
        <member name="M:CatLib.Routing.Route.DispatchToAction(CatLib.Routing.Request,CatLib.Routing.Response)">
            <summary>
            调度到行为
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
        </member>
        <member name="M:CatLib.Routing.Route.ThroughRouteMiddleware(CatLib.Routing.Request,CatLib.Routing.Response,System.Object,System.Action{CatLib.Routing.Request,CatLib.Routing.Response,System.Object})">
            <summary>
            通过路由中间件
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="context">上下文</param>
            <param name="callback">完成中间件的回调</param>
        </member>
        <member name="M:CatLib.Routing.Route.ActionCall(CatLib.Routing.Request,CatLib.Routing.Response,System.Object)">
            <summary>
            行为调用
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="context">上下文</param>
        </member>
        <member name="M:CatLib.Routing.Route.ThroughControllerMiddleware(CatLib.Routing.Request,CatLib.Routing.Response,System.Action{CatLib.Routing.Request,CatLib.Routing.Response,System.Object})">
            <summary>
            通过控制器中间件
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="callback">回调</param>
        </member>
        <member name="M:CatLib.Routing.Route.ControllerCallRouteMiddlewareWrap(CatLib.Routing.Request,CatLib.Routing.Response,System.Object)">
            <summary>
            控制器调用路由中间件包装
            </summary>
            <param name="request"></param>
            <param name="response"></param>
            <param name="context"></param>
        </member>
        <member name="M:CatLib.Routing.Route.ControllerCall(CatLib.Routing.Request,CatLib.Routing.Response,System.Object)">
            <summary>
            控制器调用
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="context">上下文</param>
        </member>
        <member name="M:CatLib.Routing.Route.ClearCompile">
            <summary>
            清空路由编译条目
            </summary>
        </member>
        <member name="M:CatLib.Routing.Route.CompileRoute">
            <summary>
            编译路由条目
            </summary>
        </member>
        <member name="T:CatLib.Routing.RouteAction">
            <summary>
            路由行为
            </summary>
        </member>
        <member name="T:CatLib.Routing.RouteAction.RouteTypes">
            <summary>
            路由行为类型
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteAction.RouteTypes.CallBack">
            <summary>
            回调形路由
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteAction.RouteTypes.ControllerCall">
            <summary>
            控制器调用
            </summary>
        </member>
        <member name="P:CatLib.Routing.RouteAction.Type">
            <summary>
            类型
            </summary>
        </member>
        <member name="P:CatLib.Routing.RouteAction.Action">
            <summary>
            回调行为
            </summary>
        </member>
        <member name="P:CatLib.Routing.RouteAction.Controller">
            <summary>
            控制器
            </summary>
        </member>
        <member name="P:CatLib.Routing.RouteAction.Func">
            <summary>
            调度函数名
            </summary>
        </member>
        <member name="T:CatLib.Routing.RouteCompiler">
            <summary>
            路由条目编译器
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteCompiler.Separators">
            <summary>
            分隔符
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteCompiler.VariableMaximumLength">
            <summary>
            变量最大长度
            </summary>
        </member>
        <member name="M:CatLib.Routing.RouteCompiler.Compile(CatLib.Routing.Route)">
            <summary>
            编译路由条目
            </summary>
            <returns>编译后的路由条目</returns>
        </member>
        <member name="M:CatLib.Routing.RouteCompiler.CompilePattern(CatLib.Routing.Route,System.String,System.Boolean)">
            <summary>
            编译参数
            </summary>
            <param name="route">路由条目</param>
            <param name="uri">uri</param>
            <param name="isHost">是否是host</param>
            <returns>编译数据</returns>
        </member>
        <member name="M:CatLib.Routing.RouteCompiler.ComputeRegexp(System.Collections.Generic.IList{System.String[]},System.Int32,System.Int32)">
            <summary>
            计算表达式
            </summary>
            <param name="tokens">处理块</param>
            <param name="index">第几个下标</param>
            <param name="firstOptional">第一个可选项的下标</param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.RouteCompiler.FindNextSeparator(System.String)">
            <summary>
            搜索下一个分隔符
            </summary>
            <param name="uri">uri</param>
            <returns>下一个分隔符</returns>
        </member>
        <member name="M:CatLib.Routing.RouteCompiler.IsMatch(System.String,System.String)">
            <summary>
            是否匹配
            </summary>
            <param name="val">输入值</param>
            <param name="regstr">正则表达式</param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.RouteCompiler.MatchParameters(System.String,System.String,System.Int32[]@)">
            <summary>
            获取参数
            </summary>
            <param name="uri">uri</param>
            <param name="regstr">正则表达式</param>
            <param name="parameIndex">参数下标</param>
            <returns>匹配到的参数</returns>
        </member>
        <member name="T:CatLib.Routing.RouteGroup">
            <summary>
            路由组
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteGroup.options">
            <summary>
            路由配置
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteGroup.routes">
            <summary>
            在路由组中的路由条目
            </summary>
        </member>
        <member name="M:CatLib.Routing.RouteGroup.#ctor">
            <summary>
            路由组
            </summary>
        </member>
        <member name="M:CatLib.Routing.RouteGroup.AddRoute(CatLib.API.Routing.IRoute)">
            <summary>
            增加路由条目到路由组中
            </summary>
            <param name="route">路由条目</param>
            <returns>当前路由组实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteGroup.Defaults(System.String,System.String)">
            <summary>
            设定参数的默认值
            </summary>
            <param name="name">参数名</param>
            <param name="val">参数值</param>
            <returns>当前路由组实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteGroup.Where(System.String,System.String)">
            <summary>
            约束指定参数必须符合正则表达式
            </summary>
            <param name="name">参数名</param>
            <param name="pattern">约束的正则表达式</param>
            <returns>当前路由组实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteGroup.Middleware(System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse}},System.Int32)">
            <summary>
            添加路由中间件
            </summary>
            <param name="middleware">中间件</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>当前路由组实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteGroup.OnError(System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception}},System.Int32)">
            <summary>
            当路由出现错误时
            </summary>
            <param name="onError">错误处理函数</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>当前路由组实例</returns>
        </member>
        <member name="T:CatLib.Routing.RouteOptions">
            <summary>
            路由配置
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteOptions.middleware">
            <summary>
            路由请求过滤链
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteOptions.onError">
            <summary>
            当路由出现异常时的过滤器链
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteOptions.wheres">
            <summary>
            筛选条件
            </summary>
        </member>
        <member name="F:CatLib.Routing.RouteOptions.defaults">
            <summary>
            默认值
            </summary>
        </member>
        <member name="E:CatLib.Routing.RouteOptions.OnCompiledChange">
            <summary>
            当被编译的内容发生改变时
            </summary>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.GetDefaults(System.String,System.String)">
            <summary>
            获取参数默认值
            </summary>
            <param name="name">参数名</param>
            <param name="defaultValue">默认值</param>
            <returns>默认值</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.GetWhere(System.String)">
            <summary>
            获取筛选条件
            </summary>
            <param name="varName">变量名</param>
            <returns>筛选条件,如果不存在则返回null</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.Where(System.String,System.String,System.Boolean)">
            <summary>
            约束指定参数必须符合指定模式才会被路由
            </summary>
            <param name="name">名字</param>
            <param name="pattern">约束条件</param>
            <param name="overrided">是否覆盖配置</param>
            <returns>当前路由配置实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.Defaults(System.String,System.String,System.Boolean)">
            <summary>
            设定默认值
            </summary>
            <param name="name">参数名</param>
            <param name="val">默认值</param>
            <param name="overrided">是否覆盖配置</param>
            <returns>当前路由配置实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.OnError(System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception}},System.Int32)">
            <summary>
            当路由出现错误时
            </summary>
            <param name="onError">错误处理函数</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>当前路由配置实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.Middleware(System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse}},System.Int32)">
            <summary>
            路由中间件
            </summary>
            <param name="middleware">中间件</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>当前路由配置实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.GatherMiddleware">
            <summary>
            获取路由的中间件
            </summary>
            <returns>中间件过滤器链</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.GatherOnError">
            <summary>
            获取当出现错误时的过滤器链
            </summary>
            <returns>错误处理过滤器链</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.Merge(CatLib.Routing.RouteOptions)">
            <summary>
            将当前路由配置中的信息合并到给定的路由配置中
            </summary>
            <param name="options">路由配置</param>
            <returns>当前路由配置实例</returns>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.MergeMiddleware(CatLib.Routing.RouteOptions)">
            <summary>
            合并中间件
            </summary>
            <param name="options">外部路由配置</param>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.MergeOnError(CatLib.Routing.RouteOptions)">
            <summary>
            合并错误时的调度
            </summary>
            <param name="options">外部路由配置</param>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.MergeWhere(CatLib.Routing.RouteOptions)">
            <summary>
            合并where
            </summary>
            <param name="options">外部路由配置</param>
        </member>
        <member name="M:CatLib.Routing.RouteOptions.MergeDefaults(CatLib.Routing.RouteOptions)">
            <summary>
            合并默认值
            </summary>
            <param name="options">外部路由配置</param>
        </member>
        <member name="T:CatLib.Routing.RouteParameterBinder">
            <summary>
            路由参数绑定
            </summary>
        </member>
        <member name="M:CatLib.Routing.RouteParameterBinder.Parameters(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            获取参数
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
        </member>
        <member name="M:CatLib.Routing.RouteParameterBinder.BindPathParameters(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            匹配路径
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
        </member>
        <member name="M:CatLib.Routing.RouteParameterBinder.BindHostParameters(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            匹配Host
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
        </member>
        <member name="M:CatLib.Routing.RouteParameterBinder.BindQueryParameters(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            匹配绑定参数
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
        </member>
        <member name="M:CatLib.Routing.RouteParameterBinder.MatchToKeys(CatLib.Routing.Route,CatLib.Routing.Request,System.Text.RegularExpressions.Match)">
            <summary>
            匹配路径中的key
            </summary>
            <param name="route"></param>
            <param name="request"></param>
            <param name="matches"></param>
        </member>
        <member name="M:CatLib.Routing.RouteParameterBinder.ReplaceDefaults(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            将没有传入的参数替换为默认参数
            </summary>
            <param name="route"></param>
            <param name="request"></param>
        </member>
        <member name="T:CatLib.Routing.Router">
            <summary>
            路由服务
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.Separator">
            <summary>
            分隔符
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.dispatcher">
            <summary>
            全局调度器
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.container">
            <summary>
            容器
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.schemes">
            <summary>
            协议方案
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.onNotFound">
            <summary>
            当路由没有找到时过滤链
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.middleware">
            <summary>
            路由请求中间件
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.onError">
            <summary>
            当出现异常时的过滤器链
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.routeGroup">
            <summary>
            路由组
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.routeGroupStack">
            <summary>
            路由组堆栈
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.requestStack">
            <summary>
            请求堆栈
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.routeStack">
            <summary>
            路由条目调用堆栈
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.responseStack">
            <summary>
            响应堆栈
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.defaultScheme">
            <summary>
            默认的scheme
            </summary>
        </member>
        <member name="F:CatLib.Routing.Router.syncRoot">
            <summary>
            同步锁
            </summary>
        </member>
        <member name="M:CatLib.Routing.Router.#ctor(CatLib.API.Events.IDispatcher,CatLib.IContainer)">
            <summary>
            创建一个新的路由器
            </summary>
            <param name="dispatcher">事件调度器</param>
            <param name="container">容器</param>
        </member>
        <member name="M:CatLib.Routing.Router.SetDefaultScheme(System.String)">
            <summary>
            设定默认的scheme
            </summary>
            <param name="scheme">默认的scheme</param>
            <returns>当前实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.GetDefaultScheme">
            <summary>
            获取默认的scheme
            </summary>
            <returns>默认scheme</returns>
        </member>
        <member name="M:CatLib.Routing.Router.Reg(System.String,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse})">
            <summary>
            根据回调行为注册一个路由
            </summary>
            <param name="uris">统一资源标识符</param>
            <param name="action">行为</param>
            <returns>当前实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.Reg(System.String,System.Type,System.String)">
            <summary>
            根据控制器的type和调用的方法名字注册一个路由
            </summary>
            <param name="uris">uri</param>
            <param name="controller">控制器类型</param>
            <param name="func">调用的方法名</param>
            <returns>当前实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.OnNotFound(System.Action{CatLib.API.Routing.IRequest,System.Action{CatLib.API.Routing.IRequest}},System.Int32)">
            <summary>
            当路由没有找到时
            </summary>
            <param name="middleware">中间件</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>当前实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.Middleware(System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse}},System.Int32)">
            <summary>
            全局路由中间件
            </summary>
            <param name="middleware">中间件</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>当前路由器实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.OnError(System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception,System.Action{CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception}},System.Int32)">
            <summary>
            当路由出现错误时
            </summary>
            <param name="onError">错误处理函数</param>
            <param name="priority">优先级(值越小越优先)</param>
            <returns>当前实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.Dispatch(System.String,System.Object)">
            <summary>
            调度路由
            </summary>
            <param name="uri">路由地址</param>
            <param name="context">上下文</param>
            <returns>请求响应</returns>
        </member>
        <member name="M:CatLib.Routing.Router.Group(System.String)">
            <summary>
            建立或者获取一个已经建立的路由组
            </summary>
            <param name="name">路由组名字</param>
            <returns>当前实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.Group(System.Action,System.String)">
            <summary>
            建立匿名路由组，调用的闭包内为路由组有效范围, 允许给定一个名字来显示命名路由组
            </summary>
            <param name="area">区域</param>
            <param name="name">路由组名字</param>
            <returns>当前实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.RouterCompiler">
            <summary>
            路由器编译
            </summary>
            <returns>迭代器</returns>
        </member>
        <member name="M:CatLib.Routing.Router.GuardCircularDependency(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            保证不处于循环依赖调用
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
        </member>
        <member name="M:CatLib.Routing.Router.EnvironmentPreparation(CatLib.Routing.Route,CatLib.Routing.Request,CatLib.Routing.Response,System.Boolean)">
            <summary>
            环境预备
            </summary>
            <param name="route">路由</param>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="isRollback">是否回滚</param>
        </member>
        <member name="M:CatLib.Routing.Router.ThrowException(CatLib.Routing.Route,CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception)">
            <summary>
            触发异常冒泡
            </summary>
            <param name="route">路由条目</param>
            <param name="request">当前请求</param>
            <param name="response">当前响应</param>
            <param name="ex">异常</param>
            <returns>冒泡是否已经被拦截</returns>
        </member>
        <member name="M:CatLib.Routing.Router.RegisterRoute(System.String,CatLib.Routing.RouteAction)">
            <summary>
            注册一个路由方案
            </summary>
            <param name="uris">统一资源标识符</param>
            <param name="action">行为</param>
            <returns>当前实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.MakeRoute(CatLib.Routing.Uri,CatLib.Routing.RouteAction)">
            <summary>
            产生一个路由条目
            </summary>
            <param name="uri">uri</param>
            <param name="action">路由行为</param>
            <returns>路由条目</returns>
        </member>
        <member name="M:CatLib.Routing.Router.ThrowOnNotFound(CatLib.API.Routing.IRequest)">
            <summary>
            触发没有找到路由的过滤器链
            </summary>
            <param name="request">请求</param>
            <returns>冒泡是否已经被拦截</returns>
        </member>
        <member name="M:CatLib.Routing.Router.ThrowOnError(CatLib.API.Routing.IRequest,CatLib.API.Routing.IResponse,System.Exception)">
            <summary>
            触发异常
            </summary>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <param name="ex">异常</param>
            <returns>冒泡是否已经被拦截</returns>
        </member>
        <member name="M:CatLib.Routing.Router.RunRouteWithMiddleware(CatLib.Routing.Route,CatLib.Routing.Request,CatLib.Routing.Response)">
            <summary>
            通过中间件后执行路由请求
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
            <param name="response">响应</param>
            <returns>响应</returns>
        </member>
        <member name="M:CatLib.Routing.Router.MakeScheme(System.String)">
            <summary>
            增加一个处理方案
            </summary>
            <param name="name">scheme名字</param>
            <returns>当前路由实例</returns>
        </member>
        <member name="M:CatLib.Routing.Router.FindRoute(CatLib.Routing.Request)">
            <summary>
            查找一个合适的路由
            </summary>
            <param name="request">请求</param>
            <returns>命中的路由</returns>
        </member>
        <member name="M:CatLib.Routing.Router.MakeRequest(System.String,System.Object)">
            <summary>
            创建请求
            </summary>
            <param name="uri">uri</param>
            <param name="context">上下文</param>
            <returns>请求</returns>
        </member>
        <member name="M:CatLib.Routing.Router.Prefix(System.String)">
            <summary>
            处理uri为符合规则的url
            </summary>
            <param name="url">url</param>
            <returns>处理后的url</returns>
        </member>
        <member name="M:CatLib.Routing.Router.GetLastGroupPrefix">
            <summary>
            获取最后的分组信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:CatLib.Routing.Router.GuardUri(System.String)">
            <summary>
            uri 保护
            </summary>
            <param name="uri">uri</param>
            <returns>处理后的uri</returns>
        </member>
        <member name="T:CatLib.Routing.RoutingProvider">
            <summary>
            路由服务
            </summary>
        </member>
        <member name="P:CatLib.Routing.RoutingProvider.DefaultScheme">
            <summary>
            默认的Scheme
            </summary>
        </member>
        <member name="P:CatLib.Routing.RoutingProvider.RouterCompiler">
            <summary>
            是否进行路由编译
            </summary>
        </member>
        <member name="P:CatLib.Routing.RoutingProvider.CompilerAssembly">
            <summary>
            会进行属性路由编译的程序集
            </summary>
        </member>
        <member name="M:CatLib.Routing.RoutingProvider.#ctor">
            <summary>
            路由服务
            </summary>
        </member>
        <member name="M:CatLib.Routing.RoutingProvider.Init">
            <summary>
            执行路由编译，路由编译总是最后进行的
            </summary>
            <returns>迭代器</returns>
        </member>
        <member name="M:CatLib.Routing.RoutingProvider.Register">
            <summary>
            注册路由条目
            </summary>
        </member>
        <member name="M:CatLib.Routing.RoutingProvider.RegisterAttrRouteCompiler">
            <summary>
            注册属性路由编译器
            </summary>
        </member>
        <member name="T:CatLib.Routing.Scheme">
            <summary>
            方案
            </summary>
        </member>
        <member name="F:CatLib.Routing.Scheme.routes">
            <summary>
            路由条目列表
            </summary>
        </member>
        <member name="F:CatLib.Routing.Scheme.name">
            <summary>
            方案名
            </summary>
        </member>
        <member name="P:CatLib.Routing.Scheme.Name">
            <summary>
            Scheme Name
            </summary>
        </member>
        <member name="M:CatLib.Routing.Scheme.#ctor(System.String)">
            <summary>
            新建一个方案
            </summary>
            <param name="name">方案名</param>
        </member>
        <member name="M:CatLib.Routing.Scheme.AddRoute(CatLib.Routing.Route)">
            <summary>
            增加一个路由
            </summary>
            <param name="route">路由条目</param>
        </member>
        <member name="M:CatLib.Routing.Scheme.Match(CatLib.Routing.Request)">
            <summary>
            匹配一个路由
            </summary>
            <param name="request">请求</param>
            <returns>匹配到的路由条目</returns>
        </member>
        <member name="M:CatLib.Routing.Scheme.MatchAgainstRoutes(CatLib.Routing.Request)">
            <summary>
            匹配路由
            </summary>
            <param name="request">请求</param>
            <returns>匹配到的路由条目</returns>
        </member>
        <member name="T:CatLib.Routing.Uri">
            <summary>
            Uri
            </summary>
        </member>
        <member name="F:CatLib.Routing.Uri.uri">
            <summary>
            原始uri
            </summary>
        </member>
        <member name="P:CatLib.Routing.Uri.Original">
            <summary>
            原始Uri信息
            </summary>
        </member>
        <member name="M:CatLib.Routing.Uri.#ctor(System.String)">
            <summary>
            Uri
            </summary>
            <param name="uri">uri</param>
        </member>
        <member name="M:CatLib.Routing.Uri.#ctor(System.Uri)">
            <summary>
            Uri
            </summary>
            <param name="uri">uri</param>
        </member>
        <member name="P:CatLib.Routing.Uri.FullPath">
            <summary>
            全路径(全路径不包含userinfo) eg: catlib://login/register?id=10
            </summary>
        </member>
        <member name="P:CatLib.Routing.Uri.NoParamFullPath">
            <summary>
            无参的全路径 eg:catlib://login/register
            </summary>
        </member>
        <member name="P:CatLib.Routing.Uri.Scheme">
            <summary>
            方案 eg: catlib
            </summary>
        </member>
        <member name="P:CatLib.Routing.Uri.Host">
            <summary>
            host eg: login
            </summary>
        </member>
        <member name="P:CatLib.Routing.Uri.UserInfo">
            <summary>
            请求中附带的用户信息
            </summary>
        </member>
        <member name="P:CatLib.Routing.Uri.Segments">
            <summary>
            片段
            </summary>
        </member>
        <member name="T:CatLib.Routing.HostValidator">
            <summary>
            Host验证器
            </summary>
        </member>
        <member name="M:CatLib.Routing.HostValidator.Matches(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            是否匹配
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
            <returns>是否匹配</returns>
        </member>
        <member name="T:CatLib.Routing.IValidators">
            <summary>
            验证器
            </summary>
        </member>
        <member name="M:CatLib.Routing.IValidators.Matches(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            是否匹配
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
            <returns>是否匹配</returns>
        </member>
        <member name="T:CatLib.Routing.UriValidator">
            <summary>
            统一资源定位符验证器
            </summary>
        </member>
        <member name="M:CatLib.Routing.UriValidator.Matches(CatLib.Routing.Route,CatLib.Routing.Request)">
            <summary>
            是否匹配
            </summary>
            <param name="route">路由条目</param>
            <param name="request">请求</param>
            <returns>是否匹配</returns>
        </member>
        <member name="T:CatLib.Application">
            <summary>
            CatLib程序
            </summary>
        </member>
        <member name="F:CatLib.Application.version">
            <summary>
            版本号
            </summary>
        </member>
        <member name="T:CatLib.Application.StartProcess">
            <summary>
            框架启动流程
            </summary>
        </member>
        <member name="F:CatLib.Application.StartProcess.Construct">
            <summary>
            构建阶段
            </summary>
        </member>
        <member name="F:CatLib.Application.StartProcess.Bootstrap">
            <summary>
            引导流程
            </summary>
        </member>
        <member name="F:CatLib.Application.StartProcess.Bootstraped">
            <summary>
            引导流程结束
            </summary>
        </member>
        <member name="F:CatLib.Application.StartProcess.Initing">
            <summary>
            初始化中
            </summary>
        </member>
        <member name="F:CatLib.Application.StartProcess.Inited">
            <summary>
            初始化完成
            </summary>
        </member>
        <member name="F:CatLib.Application.serviceProviders">
            <summary>
            服务提供者
            </summary>
        </member>
        <member name="F:CatLib.Application.serviceProviderTypes">
            <summary>
            注册服务提供者
            </summary>
        </member>
        <member name="F:CatLib.Application.bootstrapped">
            <summary>
            是否已经完成引导程序
            </summary>
        </member>
        <member name="F:CatLib.Application.inited">
            <summary>
            是否已经完成初始化
            </summary>
        </member>
        <member name="F:CatLib.Application.process">
            <summary>
            启动流程
            </summary>
        </member>
        <member name="P:CatLib.Application.Process">
            <summary>
            启动流程
            </summary>
        </member>
        <member name="F:CatLib.Application.incrementId">
            <summary>
            增量Id
            </summary>
        </member>
        <member name="F:CatLib.Application.mainThreadId">
            <summary>
            主线程ID
            </summary>
        </member>
        <member name="P:CatLib.Application.IsMainThread">
            <summary>
            是否是主线程
            </summary>
        </member>
        <member name="F:CatLib.Application.dispatcher">
            <summary>
            事件系统
            </summary>
        </member>
        <member name="P:CatLib.Application.Dispatcher">
            <summary>
            事件系统
            </summary>
        </member>
        <member name="M:CatLib.Application.#ctor">
            <summary>
            构建一个CatLib实例
            </summary>
        </member>
        <member name="M:CatLib.Application.Bootstrap(CatLib.IBootstrap[])">
            <summary>
            引导程序
            </summary>
            <param name="bootstraps">引导程序</param>
            <returns>CatLib实例</returns>
            <exception cref="T:System.ArgumentNullException">当引导类型为null时引发</exception>
        </member>
        <member name="M:CatLib.Application.Init">
            <summary>
            初始化
            </summary>
            <exception cref="T:CatLib.RuntimeException">没有调用<c>Bootstrap(...)</c>就尝试初始化时触发</exception>
        </member>
        <member name="M:CatLib.Application.Register(CatLib.IServiceProvider)">
            <summary>
            注册服务提供者
            </summary>
            <param name="provider">注册服务提供者</param>
            <exception cref="T:CatLib.RuntimeException">服务提供者被重复注册时触发</exception>
        </member>
        <member name="M:CatLib.Application.IsRegisted(CatLib.IServiceProvider)">
            <summary>
            服务提供者是否已经注册过
            </summary>
            <param name="provider">服务提供者</param>
            <returns>服务提供者是否已经注册过</returns>
        </member>
        <member name="M:CatLib.Application.GetRuntimeId">
            <summary>
            获取运行时唯一Id
            </summary>
            <returns>应用程序内唯一id</returns>
        </member>
        <member name="M:CatLib.Application.GetPriority(System.Type,System.String)">
            <summary>
            获取优先级
            </summary>
            <param name="type">识别的类型</param>
            <param name="method">识别的方法</param>
            <returns>优先级</returns>
        </member>
        <member name="M:CatLib.Application.SetDebugLevel(CatLib.DebugLevels)">
            <summary>
            设定调试等级
            </summary>
            <param name="level">调试等级</param>
        </member>
        <member name="M:CatLib.Application.Trigger(System.String,System.Object)">
            <summary>
            触发一个事件,并获取事件的返回结果
            </summary>
            <param name="eventName">事件名称</param>
            <param name="payload">载荷</param>
            <returns>事件结果</returns>
        </member>
        <member name="M:CatLib.Application.TriggerHalt(System.String,System.Object)">
            <summary>
            触发一个事件,遇到第一个事件存在处理结果后终止,并获取事件的返回结果
            </summary>
            <param name="eventName">事件名</param>
            <param name="payload">载荷</param>
            <returns>事件结果</returns>
        </member>
        <member name="M:CatLib.Application.On(System.String,System.Action{System.Object},System.Int32)">
            <summary>
            注册一个事件
            </summary>
            <param name="eventName">事件名称</param>
            <param name="handler">事件句柄</param>
            <param name="life">在几次后事件会被自动释放</param>
            <returns>事件句柄</returns>
        </member>
        <member name="M:CatLib.Application.Listen(System.String,System.Func{System.Object,System.Object},System.Int32)">
            <summary>
            注册一个事件
            </summary>
            <param name="eventName">事件名称</param>
            <param name="handler">事件句柄</param>
            <param name="life">在几次后事件会被自动释放</param>
            <returns>事件句柄</returns>
        </member>
        <member name="M:CatLib.Application.Off(System.String,System.Action{System.Object})">
            <summary>
            反注册一个事件
            </summary>
            <param name="eventName">事件名</param>
            <param name="handler">事件句柄</param>
        </member>
        <member name="P:CatLib.Application.Version">
            <summary>
            CatLib版本(遵循semver)
            </summary>
        </member>
        <member name="M:CatLib.Application.Compare(System.Int32,System.Int32,System.Int32)">
            <summary>
            比较CatLib版本(遵循semver)
            <para>输入版本大于当前版本则返回<code>-1</code></para>
            <para>输入版本等于当前版本则返回<code>0</code></para>
            <para>输入版本小于当前版本则返回<code>1</code></para>
            </summary>
            <param name="major">主版本号</param>
            <param name="minor">次版本号</param>
            <param name="revised">修订版本号</param>
            <returns>比较结果</returns>
        </member>
        <member name="M:CatLib.Application.Compare(System.String)">
            <summary>
            比较CatLib版本(遵循semver)
            <para>输入版本大于当前版本则返回<code>-1</code></para>
            <para>输入版本等于当前版本则返回<code>0</code></para>
            <para>输入版本小于当前版本则返回<code>1</code></para>
            </summary>
            <param name="version">版本号</param>
            <returns>比较结果</returns>
        </member>
        <member name="M:CatLib.Application.GetProviderBaseType(CatLib.IServiceProvider)">
            <summary>
            获取服务提供者基础类型
            </summary>
            <param name="provider">服务提供者</param>
            <returns>基础类型</returns>
        </member>
        <member name="M:CatLib.Application.RegisterCoreAlias">
            <summary>
            注册核心别名
            </summary>
        </member>
        <member name="M:CatLib.Application.GuardDispatcher">
            <summary>
            验证调度器是否有效
            </summary>
        </member>
        <member name="T:CatLib.Translation.ISelector">
            <summary>
            选择器
            </summary>
        </member>
        <member name="M:CatLib.Translation.ISelector.Choose(System.String,System.Int32,System.String)">
            <summary>
            对翻译进行处理
            </summary>
            <param name="line">语言字符串</param>
            <param name="number">数量</param>
            <param name="locale">语言</param>
            <returns>处理后的字符串</returns>
        </member>
        <member name="T:CatLib.Translation.Selector">
            <summary>
            选择器
            </summary>
        </member>
        <member name="F:CatLib.Translation.Selector.StripMatchStr">
            <summary>
            区间匹配表达式
            </summary>
        </member>
        <member name="F:CatLib.Translation.Selector.extractReg">
            <summary>
            展开处理匹配式
            </summary>
        </member>
        <member name="M:CatLib.Translation.Selector.Choose(System.String,System.Int32,System.String)">
            <summary>
            对翻译进行处理
            </summary>
            <param name="line">语言字符串</param>
            <param name="number">数量</param>
            <param name="locale">语言</param>
            <returns>处理后的字符串</returns>
        </member>
        <member name="M:CatLib.Translation.Selector.Extract(System.String[],System.Int32)">
            <summary>
            处理
            </summary>
            <param name="segments">片段</param>
            <param name="number">数字</param>
            <returns>字符串</returns>
        </member>
        <member name="M:CatLib.Translation.Selector.RangeExtract(System.String,System.Int32)">
            <summary>
            范围处理
            </summary>
            <param name="parts">单片段</param>
            <param name="number">数字</param>
            <returns></returns>
        </member>
        <member name="M:CatLib.Translation.Selector.StripConditions(System.String[])">
            <summary>
            过滤未被处理的片段
            </summary>
            <param name="segments">片段</param>
            <returns>处理后的结果</returns>
        </member>
        <member name="M:CatLib.Translation.Selector.GetPluralIndex(System.String,System.Int32)">
            <summary>
            获取语言的复数形式
            
            语言复数形式规则来自于：Zend Framework
            The plural rules are derived from code of the Zend Framework (2010-09-25), which
            is subject to the new BSD license(http://framework.zend.com/license/new-bsd)
            Copyright (c) 2005-2010 - Zend Technologies USA Inc. (http://www.zend.com)
            </summary>
            <param name="locale">语言</param>
            <param name="number">数量</param>
            <returns>复数形式</returns>
        </member>
        <member name="T:CatLib.Translation.TranslationProvider">
            <summary>
            国际化服务提供者
            </summary>
        </member>
        <member name="P:CatLib.Translation.TranslationProvider.DefaultLanguage">
            <summary>
            默认语言
            </summary>
        </member>
        <member name="P:CatLib.Translation.TranslationProvider.FallbackLanguage">
            <summary>
            备选语言
            </summary>
        </member>
        <member name="M:CatLib.Translation.TranslationProvider.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:CatLib.Translation.TranslationProvider.Register">
            <summary>
            当注册国际化服务时
            </summary>
        </member>
        <member name="T:CatLib.Translation.Translator">
            <summary>
            国际化(I18N)
            语言代码使用 ISO 639, ISO 639-1, ISO 639-2, ISO 639-3 标准
            </summary>
        </member>
        <member name="F:CatLib.Translation.Translator.selector">
            <summary>
            消息选择器
            </summary>
        </member>
        <member name="F:CatLib.Translation.Translator.locale">
            <summary>
            当前语言
            </summary>
        </member>
        <member name="F:CatLib.Translation.Translator.fallback">
            <summary>
            备选语言
            </summary>
        </member>
        <member name="F:CatLib.Translation.Translator.resources">
            <summary>
            翻译翻译资源
            </summary>
        </member>
        <member name="M:CatLib.Translation.Translator.SetResources(CatLib.API.Translation.ITranslateResources)">
            <summary>
            设定翻译资源
            </summary>
            <param name="map">映射</param>
        </member>
        <member name="M:CatLib.Translation.Translator.SetFallback(System.String)">
            <summary>
            设定替补语言
            </summary>
            <param name="fallback">替补语言</param>
        </member>
        <member name="M:CatLib.Translation.Translator.SetSelector(CatLib.Translation.ISelector)">
            <summary>
            设定消息选择器
            </summary>
            <param name="selector">选择器</param>
        </member>
        <member name="M:CatLib.Translation.Translator.GetBy(System.String,System.Int32,System.String[],System.String[])">
            <summary>
            依次遍历给定的语言获取翻译,翻译根据传入数量使用指定复数形式,如果都没有命中则使用替补语言
            </summary>
            <param name="key">键</param>
            <param name="number">数量</param>
            <param name="locales">遍历的语言</param>
            <param name="replace">替换翻译内容的占位符</param>
            <returns>翻译后的内容</returns>
        </member>
        <member name="M:CatLib.Translation.Translator.GetBy(System.String,System.String[],System.String[])">
            <summary>
            依次遍历给定的语言获取翻译,如果都没有命中则使用替补语言
            </summary>
            <param name="key">键</param>
            <param name="locales">多语言</param>
            <param name="replace">替换翻译内容的占位符</param>
            <returns>翻译的内容</returns>
        </member>
        <member name="M:CatLib.Translation.Translator.GetBy(System.String,System.Int32,System.String,System.String[])">
            <summary>
            从指定的语言获取翻译,翻译根据传入数量使用指定复数形式,如果没有命中则使用替补语言
            </summary>
            <param name="key">键</param>
            <param name="number">语言</param>
            <param name="locale">指定语言</param>
            <param name="replace">替换翻译内容的占位符</param>
            <returns>翻译后的内容</returns>
        </member>
        <member name="M:CatLib.Translation.Translator.GetBy(System.String,System.String,System.String[])">
            <summary>
            从指定的语言获取翻译,如果没有命中则使用替补语言
            </summary>
            <param name="key">键</param>
            <param name="locale">语言</param>
            <param name="replace">替换翻译内容的占位符</param>
            <returns>翻译的内容</returns>
        </member>
        <member name="M:CatLib.Translation.Translator.Get(System.String,System.String[])">
            <summary>
            在当前语言环境下翻译内容，如果没有命中则使用替补语言
            </summary>
            <param name="key">键</param>
            <param name="replace">替换翻译内容的占位符</param>
            <returns>翻译的值</returns>
        </member>
        <member name="M:CatLib.Translation.Translator.Get(System.String,System.Int32,System.String[])">
            <summary>
            在当前语言环境下翻译带有数量的内容，如果没有命中则使用替补语言
            </summary>
            <param name="key">键</param>
            <param name="number">数值</param>
            <param name="replace">替换翻译内容的占位符</param>
            <returns>翻译的值</returns>
        </member>
        <member name="M:CatLib.Translation.Translator.GetLocale">
            <summary>
            获取当前语言环境
            </summary>
            <returns></returns>
        </member>
        <member name="M:CatLib.Translation.Translator.SetLocale(System.String)">
            <summary>
            设定当前语言环境
            </summary>
            <param name="locale">设定默认本地语言(语言代码使用 ISO 639, ISO 639-1, ISO 639-2, ISO 639-3 标准)</param>
        </member>
        <member name="M:CatLib.Translation.Translator.Choice(System.String,System.Int32,System.String,System.String[])">
            <summary>
            选择性翻译（选择合适的复数形式进行翻译）
            </summary>
            <param name="key">键</param>
            <param name="number">值</param>
            <param name="locale">语言</param>
            <param name="replace">替换的内容</param>
            <returns>翻译的值</returns>
        </member>
        <member name="M:CatLib.Translation.Translator.GetLine(System.String,System.String,System.String[])">
            <summary>
            获取一行数据
            </summary>
            <param name="key">键</param>
            <param name="locale">当前语言</param>
            <param name="replace">替换的值</param>
            <returns>翻译的值</returns>
        </member>
        <member name="M:CatLib.Translation.Translator.MakeReplacements(System.String,System.String[])">
            <summary>
            替换内容
            </summary>
            <param name="line">字符串</param>
            <param name="replace">替换的内容</param>
        </member>
        <member name="T:BCrypt.Net.BCrypt">
            <summary>BCrypt implementation.</summary>
            <remarks>
             <para>
                   BCrypt implements OpenBSD-style Blowfish password hashing using the scheme described in
                   <a href="http://www.usenix.org/event/usenix99/provos/provos_html/index.html">"A Future-
                   Adaptable Password Scheme"</a> by Niels Provos and David Mazieres.
             </para>
             <para>
                   This password hashing system tries to thwart off-line password cracking using a
                   computationally-intensive hashing algorithm, based on Bruce Schneier's Blowfish cipher.
                   The work factor of the algorithm is parameterised, so it can be increased as computers
                   get faster.
             </para>
             <para>
                   Usage is really simple. To hash a password for the first time, call the <see
                   cref="M:BCrypt.Net.BCrypt.HashPassword(System.String)"/> method with a random salt, like this:
             </para>
             <code>string pw_hash = BCrypt.HashPassword(plain_password);</code>
             <para>
                   To check whether a plaintext password matches one that has been hashed previously,
                   use the <see cref="M:BCrypt.Net.BCrypt.Verify(System.String,System.String)"/> method:
             </para>
             <code>
                if (BCrypt.Verify(candidate_password, stored_hash))
                    Console.WriteLine("It matches");
                else
                    Console.WriteLine("It does not match");
              </code>
              <para>
                    The <see cref="M:BCrypt.Net.BCrypt.GenerateSalt"/> method takes an optional parameter (workFactor) that
                    determines the computational complexity of the hashing:
              </para>
              <code>
                string strong_salt = BCrypt.GenerateSalt(10);
                string stronger_salt = BCrypt.GenerateSalt(12);
              </code>
              <para>
                    The amount of work increases exponentially (2^workFactor), so each increment is twice
                    as much work. The default workFactor is 10, and the valid range is 4 to 31.
              </para>
            </remarks>
        </member>
        <member name="M:BCrypt.Net.BCrypt.HashString(System.String)">
            <summary>
             Hash a string using the OpenBSD bcrypt scheme and a salt generated by <see
             cref="M:BCrypt.Net.BCrypt.GenerateSalt"/>.
            </summary>
            <remarks>Just an alias for HashPassword.</remarks>
            <param name="source">The string to hash.</param>
            <returns>The hashed string.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.HashString(System.String,System.Int32)">
            <summary>
             Hash a string using the OpenBSD bcrypt scheme and a salt generated by <see
             cref="M:BCrypt.Net.BCrypt.GenerateSalt"/>.
            </summary>
            <remarks>Just an alias for HashPassword.</remarks>
            <param name="source">  The string to hash.</param>
            <param name="workFactor">The log2 of the number of rounds of hashing to apply - the work
                                     factor therefore increases as 2^workFactor.</param>
            <returns>The hashed string.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.HashPassword(System.String)">
            <summary>
             Hash a password using the OpenBSD bcrypt scheme and a salt generated by <see
             cref="M:BCrypt.Net.BCrypt.GenerateSalt"/>.
            </summary>
            <param name="input">The password to hash.</param>
            <returns>The hashed password.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.HashPassword(System.String,System.Int32)">
            <summary>
             Hash a password using the OpenBSD bcrypt scheme and a salt generated by <see
             cref="M:BCrypt.Net.BCrypt.GenerateSalt(System.Int32)"/> using the given <paramref name="workFactor"/>.
            </summary>
            <param name="input">     The password to hash.</param>
            <param name="workFactor">The log2 of the number of rounds of hashing to apply - the work
                                     factor therefore increases as 2^workFactor.</param>
            <returns>The hashed password.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.HashPassword(System.String,System.String)">
            <summary>Hash a password using the OpenBSD bcrypt scheme.</summary>
            <exception cref="T:System.ArgumentException">Thrown when one or more arguments have unsupported or
                                                illegal values.</exception>
            <param name="input">The password to hash.</param>
            <param name="salt">    the salt to hash with (perhaps generated using BCrypt.gensalt).</param>
            <returns>The hashed password</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.GenerateSalt(System.Int32)">
            <summary>
             Generate a salt for use with the <see cref="M:BCrypt.Net.BCrypt.HashPassword(System.String,System.String)"/> method.
            </summary>
            <param name="workFactor">The log2 of the number of rounds of hashing to apply - the work
                                     factor therefore increases as 2**workFactor.</param>
            <returns>A base64 encoded salt value.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.GenerateSalt">
            <summary>
             Generate a salt for use with the <see cref="M:BCrypt.Net.BCrypt.HashPassword(System.String,System.String)"/> method
             selecting a reasonable default for the number of hashing rounds to apply.
            </summary>
            <returns>A base64 encoded salt value.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.Verify(System.String,System.String)">
            <summary>
             Verifies that the hash of the given <paramref name="text"/> matches the provided
             <paramref name="hash"/>
            </summary>
            <param name="text">The text to verify.</param>
            <param name="hash"> The previously-hashed password.</param>
            <returns>true if the passwords match, false otherwise.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.EncodeBase64(System.Byte[],System.Int32)">
            <summary>
             Encode a byte array using bcrypt's slightly-modified base64 encoding scheme. Note that this
             is *not* compatible with the standard MIME-base64 encoding.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when one or more arguments have unsupported or
                                                illegal values.</exception>
            <param name="byteArray">The byte array to encode.</param>
            <param name="length">   The number of bytes to encode.</param>
            <returns>Base64-encoded string.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.DecodeBase64(System.String,System.Int32)">
            <summary>
             Decode a string encoded using bcrypt's base64 scheme to a byte array. Note that this is *not*
             compatible with the standard MIME-base64 encoding.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when one or more arguments have unsupported or
                                                illegal values.</exception>
            <param name="encodedstring">The string to decode.</param>
            <param name="maximumBytes"> The maximum bytes to decode.</param>
            <returns>The decoded byte array.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.Char64(System.Char)">
            <summary>
             Look up the 3 bits base64-encoded by the specified character, range-checking against
             conversion table.
            </summary>
            <param name="character">The base64-encoded value.</param>
            <returns>The decoded value of x.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.Encipher(System.UInt32[],System.Int32)">
            <summary>Blowfish encipher a single 64-bit block encoded as two 32-bit halves.</summary>
            <param name="blockArray">An array containing the two 32-bit half blocks.</param>
            <param name="offset">    The position in the array of the blocks.</param>
        </member>
        <member name="M:BCrypt.Net.BCrypt.StreamToWord(System.Byte[],System.Int32@)">
            <summary>Cycically extract a word of key material.</summary>
            <param name="data">The string to extract the data from.</param>
            <param name="offset"> [in,out] The current offset.</param>
            <returns>The next word of material from data.</returns>
        </member>
        <member name="M:BCrypt.Net.BCrypt.InitializeKey">
            <summary>Initializes the Blowfish key schedule.</summary>
        </member>
        <member name="M:BCrypt.Net.BCrypt.Key(System.Byte[])">
            <summary>Key the Blowfish cipher.</summary>
            <param name="keyBytes">The key byte array.</param>
        </member>
        <member name="M:BCrypt.Net.BCrypt.EKSKey(System.Byte[],System.Byte[])">
            <summary>
             Perform the "enhanced key schedule" step described by Provos and Mazieres in "A Future-
             Adaptable Password Scheme" http://www.openbsd.org/papers/bcrypt-paper.ps.
            </summary>
            <param name="saltBytes"> Salt byte array.</param>
            <param name="inputBytes">Input byte array.</param>
        </member>
        <member name="M:BCrypt.Net.BCrypt.CryptRaw(System.Byte[],System.Byte[],System.Int32)">
            <summary>Perform the central hashing step in the bcrypt scheme.</summary>
            <exception cref="T:System.ArgumentException">Thrown when one or more arguments have unsupported or
                                                illegal values.</exception>
            <param name="inputBytes">The input byte array to hash.</param>
            <param name="saltBytes"> The salt byte array to hash with.</param>
            <param name="logRounds"> The binary logarithm of the number of rounds of hashing to apply.</param>
            <returns>A byte array containing the hashed result.</returns>
        </member>
        <member name="T:BCrypt.Net.SaltParseException">
            <summary>Exception for signalling parse errors. </summary>
        </member>
        <member name="M:BCrypt.Net.SaltParseException.#ctor">
            <summary>Default constructor. </summary>
        </member>
        <member name="M:BCrypt.Net.SaltParseException.#ctor(System.String)">
            <summary>Initializes a new instance of <see cref="T:BCrypt.Net.SaltParseException"/>.</summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:BCrypt.Net.SaltParseException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of <see cref="T:BCrypt.Net.SaltParseException"/>.</summary>
            <param name="message">       The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:BCrypt.Net.SaltParseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Initializes a new instance of <see cref="T:BCrypt.Net.SaltParseException"/>.</summary>
            <param name="info">   The information.</param>
            <param name="context">The context.</param>
        </member>
        <member name="T:Murmur.Murmur32">
            <summary>
            
            </summary>
        </member>
        <member name="F:Murmur.Murmur32.C1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Murmur.Murmur32.C2">
            <summary>
            
            </summary>
        </member>
        <member name="M:Murmur.Murmur32.#ctor(System.UInt32)">
            <summary>
            
            </summary>
            <param name="seed"></param>
        </member>
        <member name="P:Murmur.Murmur32.HashSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:Murmur.Murmur32.Seed">
            <summary>
            
            </summary>
        </member>
        <member name="P:Murmur.Murmur32.H1">
            <summary>
            
            </summary>
        </member>
        <member name="P:Murmur.Murmur32.Length">
            <summary>
            
            </summary>
        </member>
        <member name="M:Murmur.Murmur32.Initialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Murmur.Murmur32.HashFinal">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:SimpleJson.JsonArray">
            <summary>
            Represents the json array.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonArray.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleJson.JsonArray"/> class. 
            </summary>
        </member>
        <member name="M:SimpleJson.JsonArray.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleJson.JsonArray"/> class. 
            </summary>
            <param name="capacity">The capacity of the json array.</param>
        </member>
        <member name="M:SimpleJson.JsonArray.ToString">
            <summary>
            The json representation of the array.
            </summary>
            <returns>The json representation of the array.</returns>
        </member>
        <member name="T:SimpleJson.JsonObject">
            <summary>
            Represents the json object.
            </summary>
        </member>
        <member name="F:SimpleJson.JsonObject._members">
            <summary>
            The internal member dictionary.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:SimpleJson.JsonObject"/>.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.#ctor(System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Initializes a new instance of <see cref="T:SimpleJson.JsonObject"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the key.</param>
        </member>
        <member name="P:SimpleJson.JsonObject.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Object"/> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="M:SimpleJson.JsonObject.Add(System.String,System.Object)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:SimpleJson.JsonObject.ContainsKey(System.String)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
                <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:SimpleJson.JsonObject.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
        </member>
        <member name="M:SimpleJson.JsonObject.Remove(System.String)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.TryGetValue(System.String,System.Object@)">
            <summary>
            Tries the get value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="P:SimpleJson.JsonObject.Values">
            <summary>
            Gets the values.
            </summary>
            <value>The values.</value>
        </member>
        <member name="P:SimpleJson.JsonObject.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="M:SimpleJson.JsonObject.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Adds the specified item.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SimpleJson.JsonObject.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Determines whether [contains] [the specified item].
            </summary>
            <param name="item">The item.</param>
            <returns>
            	<c>true</c> if [contains] [the specified item]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:SimpleJson.JsonObject.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
            <summary>
            Copies to.
            </summary>
            <param name="array">The array.</param>
            <param name="arrayIndex">Index of the array.</param>
        </member>
        <member name="P:SimpleJson.JsonObject.Count">
            <summary>
            Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:SimpleJson.JsonObject.IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value>
            	<c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:SimpleJson.JsonObject.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Removes the specified item.
            </summary>
            <param name="item">The item.</param>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:SimpleJson.JsonObject.ToString">
            <summary>
            Returns a json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:SimpleJson.SimpleJson">
            <summary>
            This class encodes and decodes JSON strings.
            Spec. details, see http://www.json.org/
            
            JSON uses Arrays and Objects. These correspond here to the datatypes JsonArray(IList&lt;object>) and JsonObject(IDictionary&lt;string,object>).
            All numbers are parsed to doubles.
            </summary>
        </member>
        <member name="M:SimpleJson.SimpleJson.DeserializeObject(System.String)">
            <summary>
            Parses the string json into a value
            </summary>
            <param name="json">A JSON string.</param>
            <returns>An IList&lt;object>, a IDictionary&lt;string,object>, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.TryDeserializeObject(System.String,System.Object@)">
            <summary>
            Try parsing the json string into a value.
            </summary>
            <param name="json">
            A JSON string.
            </param>
            <param name="obj">
            The object.
            </param>
            <returns>
            Returns true if successfull otherwise false.
            </returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.SerializeObject(System.Object,SimpleJson.IJsonSerializerStrategy)">
            <summary>
            Converts a IDictionary&lt;string,object> / IList&lt;object> object into a JSON string
            </summary>
            <param name="json">A IDictionary&lt;string,object> / IList&lt;object></param>
            <param name="jsonSerializerStrategy">Serializer strategy to use</param>
            <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.IsNumeric(System.Object)">
            <summary>
            Determines if a given object is numeric in any way
            (can be integer, double, null, etc).
            </summary>
        </member>
        <member name="T:MathNet.Numerics.Euclid">
            <summary>
            Integer number theory functions.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Modulus(System.Double,System.Double)">
            <summary>
            Canonical Modulus. The result has the sign of the divisor.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Modulus(System.Single,System.Single)">
            <summary>
            Canonical Modulus. The result has the sign of the divisor.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Modulus(System.Int32,System.Int32)">
            <summary>
            Canonical Modulus. The result has the sign of the divisor.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Modulus(System.Int64,System.Int64)">
            <summary>
            Canonical Modulus. The result has the sign of the divisor.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Remainder(System.Double,System.Double)">
            <summary>
            Remainder (% operator). The result has the sign of the dividend.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Remainder(System.Single,System.Single)">
            <summary>
            Remainder (% operator). The result has the sign of the dividend.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Remainder(System.Int32,System.Int32)">
            <summary>
            Remainder (% operator). The result has the sign of the dividend.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Remainder(System.Int64,System.Int64)">
            <summary>
            Remainder (% operator). The result has the sign of the dividend.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Euclid.IsEven(System.Int32)">
            <summary>
            Find out whether the provided 32 bit integer is an even number.
            </summary>
            <param name="number">The number to very whether it's even.</param>
            <returns>True if and only if it is an even number.</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.IsEven(System.Int64)">
            <summary>
            Find out whether the provided 64 bit integer is an even number.
            </summary>
            <param name="number">The number to very whether it's even.</param>
            <returns>True if and only if it is an even number.</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.IsOdd(System.Int32)">
            <summary>
            Find out whether the provided 32 bit integer is an odd number.
            </summary>
            <param name="number">The number to very whether it's odd.</param>
            <returns>True if and only if it is an odd number.</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.IsOdd(System.Int64)">
            <summary>
            Find out whether the provided 64 bit integer is an odd number.
            </summary>
            <param name="number">The number to very whether it's odd.</param>
            <returns>True if and only if it is an odd number.</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.IsPowerOfTwo(System.Int32)">
            <summary>
            Find out whether the provided 32 bit integer is a perfect power of two.
            </summary>
            <param name="number">The number to very whether it's a power of two.</param>
            <returns>True if and only if it is a power of two.</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.IsPowerOfTwo(System.Int64)">
            <summary>
            Find out whether the provided 64 bit integer is a perfect power of two.
            </summary>
            <param name="number">The number to very whether it's a power of two.</param>
            <returns>True if and only if it is a power of two.</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.IsPerfectSquare(System.Int32)">
            <summary>
            Find out whether the provided 32 bit integer is a perfect square, i.e. a square of an integer.
            </summary>
            <param name="number">The number to very whether it's a perfect square.</param>
            <returns>True if and only if it is a perfect square.</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.IsPerfectSquare(System.Int64)">
            <summary>
            Find out whether the provided 64 bit integer is a perfect square, i.e. a square of an integer.
            </summary>
            <param name="number">The number to very whether it's a perfect square.</param>
            <returns>True if and only if it is a perfect square.</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.PowerOfTwo(System.Int32)">
            <summary>
            Raises 2 to the provided integer exponent (0 &lt;= exponent &lt; 31).
            </summary>
            <param name="exponent">The exponent to raise 2 up to.</param>
            <returns>2 ^ exponent.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:MathNet.Numerics.Euclid.PowerOfTwo(System.Int64)">
            <summary>
            Raises 2 to the provided integer exponent (0 &lt;= exponent &lt; 63).
            </summary>
            <param name="exponent">The exponent to raise 2 up to.</param>
            <returns>2 ^ exponent.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:MathNet.Numerics.Euclid.Log2(System.Int32)">
            <summary>
            Evaluate the binary logarithm of an integer number.
            </summary>
            <remarks>Two-step method using a De Bruijn-like sequence table lookup.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Euclid.CeilingToPowerOfTwo(System.Int32)">
            <summary>
            Find the closest perfect power of two that is larger or equal to the provided
            32 bit integer.
            </summary>
            <param name="number">The number of which to find the closest upper power of two.</param>
            <returns>A power of two.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:MathNet.Numerics.Euclid.CeilingToPowerOfTwo(System.Int64)">
            <summary>
            Find the closest perfect power of two that is larger or equal to the provided
            64 bit integer.
            </summary>
            <param name="number">The number of which to find the closest upper power of two.</param>
            <returns>A power of two.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:MathNet.Numerics.Euclid.GreatestCommonDivisor(System.Int64,System.Int64)">
            <summary>
            Returns the greatest common divisor (<c>gcd</c>) of two integers using Euclid's algorithm.
            </summary>
            <param name="a">First Integer: a.</param>
            <param name="b">Second Integer: b.</param>
            <returns>Greatest common divisor <c>gcd</c>(a,b)</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.GreatestCommonDivisor(System.Collections.Generic.IList{System.Int64})">
            <summary>
            Returns the greatest common divisor (<c>gcd</c>) of a set of integers using Euclid's
            algorithm.
            </summary>
            <param name="integers">List of Integers.</param>
            <returns>Greatest common divisor <c>gcd</c>(list of integers)</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.GreatestCommonDivisor(System.Int64[])">
            <summary>
            Returns the greatest common divisor (<c>gcd</c>) of a set of integers using Euclid's algorithm.
            </summary>
            <param name="integers">List of Integers.</param>
            <returns>Greatest common divisor <c>gcd</c>(list of integers)</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.ExtendedGreatestCommonDivisor(System.Int64,System.Int64,System.Int64@,System.Int64@)">
            <summary>
            Computes the extended greatest common divisor, such that a*x + b*y = <c>gcd</c>(a,b).
            </summary>
            <param name="a">First Integer: a.</param>
            <param name="b">Second Integer: b.</param>
            <param name="x">Resulting x, such that a*x + b*y = <c>gcd</c>(a,b).</param>
            <param name="y">Resulting y, such that a*x + b*y = <c>gcd</c>(a,b)</param>
            <returns>Greatest common divisor <c>gcd</c>(a,b)</returns>
            <example>
            <code>
            long x,y,d;
            d = Fn.GreatestCommonDivisor(45,18,out x, out y);
            -> d == 9 &amp;&amp; x == 1 &amp;&amp; y == -2
            </code>
            The <c>gcd</c> of 45 and 18 is 9: 18 = 2*9, 45 = 5*9. 9 = 1*45 -2*18, therefore x=1 and y=-2.
            </example>
        </member>
        <member name="M:MathNet.Numerics.Euclid.LeastCommonMultiple(System.Int64,System.Int64)">
            <summary>
            Returns the least common multiple (<c>lcm</c>) of two integers using Euclid's algorithm.
            </summary>
            <param name="a">First Integer: a.</param>
            <param name="b">Second Integer: b.</param>
            <returns>Least common multiple <c>lcm</c>(a,b)</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.LeastCommonMultiple(System.Collections.Generic.IList{System.Int64})">
            <summary>
            Returns the least common multiple (<c>lcm</c>) of a set of integers using Euclid's algorithm.
            </summary>
            <param name="integers">List of Integers.</param>
            <returns>Least common multiple <c>lcm</c>(list of integers)</returns>
        </member>
        <member name="M:MathNet.Numerics.Euclid.LeastCommonMultiple(System.Int64[])">
            <summary>
            Returns the least common multiple (<c>lcm</c>) of a set of integers using Euclid's algorithm.
            </summary>
            <param name="integers">List of Integers.</param>
            <returns>Least common multiple <c>lcm</c>(list of integers)</returns>
        </member>
        <member name="T:MathNet.Numerics.Random.MersenneTwister">
            <summary>
            Random number generator using Mersenne Twister 19937 algorithm.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister.LowerMask">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister.M">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister.MatrixA">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister.N">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister.Reciprocal">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister.UpperMask">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister.Mag01">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister._mt">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.MersenneTwister._mti">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.MersenneTwister"/> class using
            a seed based on time and unique GUIDs.
            </summary>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of true to
            set whether the instance is thread safe.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.MersenneTwister"/> class using
            a seed based on time and unique GUIDs.
            </summary>
            <param name="threadSafe">if set to <c>true</c> , the class is thread safe.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.MersenneTwister"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <remarks>Uses the value of true to
            set whether the instance is thread safe.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.MersenneTwister"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <param name="threadSafe">if set to <c>true</c>, the class is thread safe.</param>
        </member>
        <member name="P:MathNet.Numerics.Random.MersenneTwister.Default">
            <summary>
            Default instance, thread-safe.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.DoSample">
            <summary>
            Returns a random double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.DoSampleInteger">
            <summary>
            Returns a random 32-bit signed integer greater than or equal to zero and less than <see cref="F:System.Int32.MaxValue"/>
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.DoSampleBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers in full range, including zero and 255 (<see cref="F:System.Byte.MaxValue"/>).
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.Doubles(System.Double[],System.Int32)">
            <summary>
            Fills an array with random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.Doubles(System.Int32,System.Int32)">
            <summary>
            Returns an array of random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.MersenneTwister.DoubleSequence(System.Int32)">
            <summary>
            Returns an infinite sequence of random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads, but the result must be enumerated from a single thread each.</remarks>
        </member>
        <member name="T:MathNet.Numerics.Random.Mrg32k3a">
            <summary>
            A 32-bit combined multiple recursive generator with 2 components of order 3.
            </summary>
            <remarks>Based off of P. L'Ecuyer, "Combined Multiple Recursive Random Number Generators," Operations Research, 44, 5 (1996), 816--822. </remarks>
            
        </member>
        <member name="M:MathNet.Numerics.Random.Mrg32k3a.#ctor">
            <summary>
            Initializes a new instance of the class using
            a seed based on time and unique GUIDs.
            </summary>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of true to
            set whether the instance is thread safe.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Mrg32k3a.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the  class using
            a seed based on time and unique GUIDs.
            </summary>
            <param name="threadSafe">if set to <c>true</c> , the class is thread safe.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.Mrg32k3a.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Mrg32k3a"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of true to
            set whether the instance is thread safe.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Mrg32k3a.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Mrg32k3a"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <param name="threadSafe">if set to <c>true</c>, the class is thread safe.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.Mrg32k3a.DoSample">
            <summary>
            Returns a random double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.Mrg32k3a.Doubles(System.Double[],System.Int32)">
            <summary>
            Fills an array with random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Mrg32k3a.Doubles(System.Int32,System.Int32)">
            <summary>
            Returns an array of random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Mrg32k3a.DoubleSequence(System.Int32)">
            <summary>
            Returns an infinite sequence of random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads, but the result must be enumerated from a single thread each.</remarks>
        </member>
        <member name="T:MathNet.Numerics.Random.RandomSeed">
            <summary>
            Random seed
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSeed.Time">
            <summary>
            Provides a time-dependent seed value, matching the default behavior of System.Random.
            WARNING: There is no randomness in this seed and quick repeated calls can cause
            the same seed value. Do not use for cryptography!
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSeed.Guid">
            <summary>
            Provides a seed based on time and unique GUIDs.
            WARNING: There is only low randomness in this seed, but at least quick repeated
            calls will result in different seed values. Do not use for cryptography!
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSeed.Robust">
            <summary>
            Provides a seed based on an internal random number generator (crypto if available), time and unique GUIDs.
            WARNING: There is only medium randomness in this seed, but quick repeated
            calls will result in different seed values. Do not use for cryptography!
            </summary>
        </member>
        <member name="T:MathNet.Numerics.Random.RandomSource">
            <summary>
            Base class for random number generators. This class introduces a layer between <see cref="T:System.Random"/>
            and the Math.Net Numerics random number generators to provide thread safety.
            When used directly it use the System.Random as random number source.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.RandomSource"/> class using
            the value of true to set whether
            the instance is thread safe or not.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.RandomSource"/> class.
            </summary>
            <param name="threadSafe">if set to <c>true</c> , the class is thread safe.</param>
            <remarks>Thread safe instances are two and half times slower than non-thread
            safe classes.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextDoubles(System.Double[])">
            <summary>
            Fills an array with uniform random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <param name="values">The array to fill with random values.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextDoubles(System.Int32)">
            <summary>
            Returns an array of uniform random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <param name="count">The size of the array to fill.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextDoubleSequence">
            <summary>
            Returns an infinite sequence of uniform random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.Next">
            <summary>
            Returns a random 32-bit signed integer greater than or equal to zero and less than <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.Next(System.Int32)">
            <summary>
            Returns a random number less then a specified maximum.
            </summary>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive ≥ 1.</param>
            <returns>A 32-bit signed integer less than <paramref name="maxExclusive"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxExclusive"/> is zero or negative.</exception>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.Next(System.Int32,System.Int32)">
            <summary>
            Returns a random number within a specified range.
            </summary>
            <param name="minInclusive">The inclusive lower bound of the random number returned.</param>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive > minExclusive.</param>
            <returns>
            A 32-bit signed integer greater than or equal to <paramref name="minInclusive"/> and less than <paramref name="maxExclusive"/>; that is, the range of return values includes <paramref name="minInclusive"/> but not <paramref name="maxExclusive"/>. If <paramref name="minInclusive"/> equals <paramref name="maxExclusive"/>, <paramref name="minInclusive"/> is returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minInclusive"/> is greater than <paramref name="maxExclusive"/>. </exception>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextInt32s(System.Int32[])">
            <summary>
            Fills an array with random 32-bit signed integers greater than or equal to zero and less than <see cref="F:System.Int32.MaxValue"/>.
            </summary>
            <param name="values">The array to fill with random values.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextInt32s(System.Int32)">
            <summary>
            Returns an array with random 32-bit signed integers greater than or equal to zero and less than <see cref="F:System.Int32.MaxValue"/>.
            </summary>
            <param name="count">The size of the array to fill.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextInt32s(System.Int32[],System.Int32)">
            <summary>
            Fills an array with random numbers within a specified range.
            </summary>
            <param name="values">The array to fill with random values.</param>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive ≥ 1.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextInt32s(System.Int32,System.Int32)">
            <summary>
            Returns an array with random 32-bit signed integers within the specified range.
            </summary>
            <param name="count">The size of the array to fill.</param>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive ≥ 1.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextInt32s(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Fills an array with random numbers within a specified range.
            </summary>
            <param name="values">The array to fill with random values.</param>
            <param name="minInclusive">The inclusive lower bound of the random number returned.</param>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive > minExclusive.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextInt32s(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns an array with random 32-bit signed integers within the specified range.
            </summary>
            <param name="count">The size of the array to fill.</param>
            <param name="minInclusive">The inclusive lower bound of the random number returned.</param>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive > minExclusive.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextInt32Sequence">
            <summary>
            Returns an infinite sequence of random 32-bit signed integers greater than or equal to zero and less than <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextInt32Sequence(System.Int32,System.Int32)">
            <summary>
            Returns an infinite sequence of random numbers within a specified range.
            </summary>
            <param name="minInclusive">The inclusive lower bound of the random number returned.</param>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive > minExclusive.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.NextBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers.
            </summary>
            <param name="buffer">An array of bytes to contain random numbers.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.Sample">
            <summary>
            Returns a random number between 0.0 and 1.0.
            </summary>
            <returns>A double-precision floating point number greater than or equal to 0.0, and less than 1.0.</returns>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.DoSample">
            <summary>
            Returns a random double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.DoSampleInteger">
            <summary>
            Returns a random 32-bit signed integer greater than or equal to zero and less than 2147483647 (<see cref="F:System.Int32.MaxValue"/>).
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.DoSampleBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers in full range, including zero and 255 (<see cref="F:System.Byte.MaxValue"/>).
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.DoSampleInt32WithNBits(System.Int32)">
            <summary>
            Returns a random N-bit signed integer greater than or equal to zero and less than 2^N.
            N (bit count) is expected to be greater than zero and less than 32 (not verified).
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.DoSampleInt64WithNBits(System.Int32)">
            <summary>
            Returns a random N-bit signed long integer greater than or equal to zero and less than 2^N.
            N (bit count) is expected to be greater than zero and less than 64 (not verified).
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.DoSampleInteger(System.Int32)">
            <summary>
            Returns a random 32-bit signed integer within the specified range.
            </summary>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive ≥ 2 (not verified, must be ensured by caller).</param>
        </member>
        <member name="M:MathNet.Numerics.Random.RandomSource.DoSampleInteger(System.Int32,System.Int32)">
            <summary>
            Returns a random 32-bit signed integer within the specified range.
            </summary>
            <param name="minInclusive">The inclusive lower bound of the random number returned.</param>
            <param name="maxExclusive">The exclusive upper bound of the random number returned. Range: maxExclusive ≥ minExclusive + 2 (not verified, must be ensured by caller).</param>
        </member>
        <member name="T:MathNet.Numerics.Random.WH2006">
            <summary>
            Wichmann-Hill’s 2006 combined multiplicative congruential generator.
            </summary>
            <remarks>See: Wichmann, B. A. &amp; Hill, I. D. (2006), "Generating good pseudo-random numbers".
            Computational Statistics &amp; Data Analysis 51:3 (2006) 1614-1622
            </remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.WH2006.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.WH2006"/> class using
            a seed based on time and unique GUIDs.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.WH2006.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.WH2006"/> class using
            a seed based on time and unique GUIDs.
            </summary>
            <param name="threadSafe">if set to <c>true</c> , the class is thread safe.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.WH2006.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.WH2006"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of true to
            set whether the instance is thread safe.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.WH2006.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.WH2006"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <remarks>The seed is set to 1, if the zero is used as the seed.</remarks>
            <param name="threadSafe">if set to <c>true</c> , the class is thread safe.</param>
        </member>
        <member name="M:MathNet.Numerics.Random.WH2006.DoSample">
            <summary>
            Returns a random double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.WH2006.Doubles(System.Double[],System.Int32)">
            <summary>
            Fills an array with random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.WH2006.Doubles(System.Int32,System.Int32)">
            <summary>
            Returns an array of random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.WH2006.DoubleSequence(System.Int32)">
            <summary>
            Returns an infinite sequence of random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads, but the result must be enumerated from a single thread each.</remarks>
        </member>
        <member name="T:MathNet.Numerics.Random.Xorshift">
            <summary>
            Implements a multiply-with-carry Xorshift pseudo random number generator (RNG) specified in Marsaglia, George. (2003). Xorshift RNGs.
            <code>Xn = a * Xn−3 + c mod 2^32</code>
            http://www.jstatsoft.org/v08/i14/paper
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift.YSeed">
            <summary>
            The default value for X1.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift.ZSeed">
            <summary>
            The default value for X2.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift.ASeed">
            <summary>
            The default value for the multiplier.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift.CSeed">
            <summary>
            The default value for the carry over.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift.UlongToDoubleMultiplier">
            <summary>
            The multiplier to compute a double-precision floating point number [0, 1)
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift._x">
            <summary>
            Seed or last but three unsigned random number.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift._y">
            <summary>
            Last but two unsigned random number.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift._z">
            <summary>
            Last but one unsigned random number.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift._c">
            <summary>
            The value of the carry over.
            </summary>
        </member>
        <member name="F:MathNet.Numerics.Random.Xorshift._a">
            <summary>
            The multiplier.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Xorshift"/> class using
            a seed based on time and unique GUIDs.
            </summary>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of true to
            set whether the instance is thread safe.
            Uses the default values of:
            <list>
            <item>a = 916905990</item>
            <item>c = 13579</item>
            <item>X1 = 77465321</item>
            <item>X2 = 362436069</item>
            </list></remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Xorshift"/> class using
            a seed based on time and unique GUIDs.
            </summary>
            <param name="a">The multiply value</param>
            <param name="c">The initial carry value.</param>
            <param name="x1">The initial value if X1.</param>
            <param name="x2">The initial value if X2.</param>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of true to
            set whether the instance is thread safe.
            Note: <paramref name="c"/> must be less than <paramref name="a"/>.
            </remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Xorshift"/> class using
            a seed based on time and unique GUIDs.
            </summary>
            <param name="threadSafe">if set to <c>true</c> , the class is thread safe.</param>
            <remarks>
            Uses the default values of:
            <list>
            <item>a = 916905990</item>
            <item>c = 13579</item>
            <item>X1 = 77465321</item>
            <item>X2 = 362436069</item>
            </list></remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.#ctor(System.Boolean,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Xorshift"/> class using
            a seed based on time and unique GUIDs.
            </summary>
            <param name="threadSafe">if set to <c>true</c> , the class is thread safe.</param>
            <param name="a">The multiply value</param>
            <param name="c">The initial carry value.</param>
            <param name="x1">The initial value if X1.</param>
            <param name="x2">The initial value if X2.</param>
            <remarks><paramref name="c"/> must be less than <paramref name="a"/>.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Xorshift"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of true to
            set whether the instance is thread safe.
            Uses the default values of:
            <list>
            <item>a = 916905990</item>
            <item>c = 13579</item>
            <item>X1 = 77465321</item>
            <item>X2 = 362436069</item>
            </list></remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.#ctor(System.Int32,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Xorshift"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of true to
            set whether the instance is thread safe.</remarks>
            <param name="a">The multiply value</param>
            <param name="c">The initial carry value.</param>
            <param name="x1">The initial value if X1.</param>
            <param name="x2">The initial value if X2.</param>
            <remarks><paramref name="c"/> must be less than <paramref name="a"/>.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Xorshift"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <param name="threadSafe">if set to <c>true</c>, the class is thread safe.</param>
            <remarks>
            Uses the default values of:
            <list>
            <item>a = 916905990</item>
            <item>c = 13579</item>
            <item>X1 = 77465321</item>
            <item>X2 = 362436069</item>
            </list></remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.#ctor(System.Int32,System.Boolean,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:MathNet.Numerics.Random.Xorshift"/> class.
            </summary>
            <param name="seed">The seed value.</param>
            <param name="threadSafe">if set to <c>true</c>, the class is thread safe.</param>
            <param name="a">The multiply value</param>
            <param name="c">The initial carry value.</param>
            <param name="x1">The initial value if X1.</param>
            <param name="x2">The initial value if X2.</param>
            <remarks><paramref name="c"/> must be less than <paramref name="a"/>.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.DoSample">
            <summary>
            Returns a random double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.DoSampleInteger">
            <summary>
            Returns a random 32-bit signed integer greater than or equal to zero and less than <see cref="F:System.Int32.MaxValue"/>
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.DoSampleBytes(System.Byte[])">
            <summary>
            Fills the elements of a specified array of bytes with random numbers in full range, including zero and 255 (<see cref="F:System.Byte.MaxValue"/>).
            </summary>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.Doubles(System.Double[],System.Int32,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Fills an array with random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.Doubles(System.Int32,System.Int32,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns an array of random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads.</remarks>
        </member>
        <member name="M:MathNet.Numerics.Random.Xorshift.DoubleSequence(System.Int32,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns an infinite sequence of random numbers greater than or equal to 0.0 and less than 1.0.
            </summary>
            <remarks>Supports being called in parallel from multiple threads, but the result must be enumerated from a single thread each.</remarks>
        </member>
    </members>
</doc>
